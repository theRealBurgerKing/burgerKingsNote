
==两数之和==
暴力解法：在i后面的数字中寻找`target-nums[i]`
哈希表写法：从左到右枚举j，将j和`nums[j]`保存到哈希表中，在哈希表中查找是否存在`target-nums[j]`

**发现：哈希表中查找一个元素的时间复杂度是O1**



==字母异位词分词==
用排序后的单词作为key，将排序前的单词存到字典中


**发现：**
d = defaultdict(list)
defaultdict 是 Python collections 模块里的一个字典，和普通 dict 的唯一区别是：访问不存在的 key 时，会自动创建一个默认值，而不是抛出 KeyError
list代表默认值是空列表，适合分组



==最长连续序列==
依然是依托哈希表中查找一个元素的时间复杂度是O1这个特性
对于set中的每个元素，查找它是否为开头（即是否存在x-1），如果为开头则循环尝试匹配x+1




==移动零==
用一个栈记录非零元素，用一个变量表示栈的大小
如果元素非0，入栈并增加栈的大小

因为nums数组前部被check过的元素没有意义了，我们可以把nums本身当作栈

最后在末尾补上0




==成最多水的容器==
双指针做法：
左边高度固定后，右边高度从右到左遍历，
如果比左高或者相等，则为当前左高度对应的最大面积，更新最大值并右移左指针
如果小于左，那么更新最大值并左移右指针，因为还可能有更大的面积




==三数之和==

**发现：遇事不决先排序**
nums.sort()


将数组排序后，枚举 nums[i]，问题变成 nums[j]+nums[k]=−nums[i]，就是两数之和问题了
如果和大于0则右指针左移，如果和小于0则左指针右移
如何避免重复的三元组：外层循环跳过相同的连续i，内层循环跳过相同的连续j和连续k




==无重复字符的最长子串==

为什么不能用dict[s[j]]直接更新i
这是个很经典的滑动窗口陷阱。
问题在于：当遇到重复字符时，dict[s[j]] 存的是该字符上一次出现的位置，但这个位置可能在当前窗口的左边界 i 的左侧。就是说已经过期的历史记录


==找到字符串中所有字母异位词==

固定大小滑动窗口+`[0]*26`数组比较



==和为k的子数组==
连续子数组问题，可以使用前缀和
因为元素不是全正数，不能使用滑动窗口

此外，从两数之和题目中我们学到可以移向，我们可以把 s[j]−s[i]=k 移项，得s[i]=s[j]−k

枚举当前的前缀和 s[j]，看看曾经有多少个前缀和等于 s[j]−k（配对）



==滑动窗口最大值==
使用单调队列

如果新员工比老员工强（或者一样强），把老员工裁掉。（元素进入窗口）
如果老员工 35 岁了，也裁掉。（元素离开窗口）
裁员后，资历最老（最左边）的人就是最强的员工了。

右边入栈（需要先清理掉左侧比入栈元素小的元素，因为他们又左又小，然后入栈）
左边出栈（如果队首过期，队首出栈）
左端点对应位置记录答案（窗口最大值就在队首）


==最小覆盖子串==

使用Counter统计出现次数
先右移右端点找当符合条件的串
再右移左端点找到最短的子串



最大子数组和
使用动态规划做

定义 f[i] 表示以 nums[i] 结尾的最大子数组和。
拼接思路，如果nums[i]左侧的子数组元素和是负的，就不跟左侧拼
