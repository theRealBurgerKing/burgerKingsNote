è¿™å¼ å¹»ç¯ç‰‡ä»‹ç» Rust ä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼š**Owned vs Copy**ï¼ˆæ‰€æœ‰æƒ vs å¤åˆ¶ï¼‰ï¼Œä»¥åŠç›¸å…³çš„ä¸‰ä¸ªé—®é¢˜ã€‚è¿™æ˜¯ç†è§£ Rust æ‰€æœ‰æƒï¼ˆownershipï¼‰å’Œå€Ÿç”¨ï¼ˆborrowingï¼‰ç³»ç»Ÿçš„å…³é”®ã€‚

## ä¸‰ä¸ªæ ¸å¿ƒé—®é¢˜

### 1. What does it mean to be an "owned" type?

**ä»€ä¹ˆæ˜¯"æ‹¥æœ‰æ‰€æœ‰æƒ"çš„ç±»å‹ï¼Ÿ**

**Owned ç±»å‹**æŒ‡çš„æ˜¯æ‹¥æœ‰å…¶æ•°æ®æ‰€æœ‰æƒçš„ç±»å‹ã€‚å½“å˜é‡æ‹¥æœ‰æ•°æ®æ—¶ï¼š

rust

```rust
let s = String::from("hello");  // s æ‹¥æœ‰è¿™ä¸ªå­—ç¬¦ä¸²æ•°æ®
```

**æ‰€æœ‰æƒè§„åˆ™ï¼š**

- æ¯ä¸ªå€¼åœ¨ Rust ä¸­éƒ½æœ‰ä¸€ä¸ª**æ‰€æœ‰è€…ï¼ˆownerï¼‰**
- åŒä¸€æ—¶é—´åªèƒ½æœ‰**ä¸€ä¸ªæ‰€æœ‰è€…**
- å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼Œå€¼ä¼šè¢«**è‡ªåŠ¨é‡Šæ”¾ï¼ˆdropï¼‰**

**ç¤ºä¾‹ï¼šæ‰€æœ‰æƒè½¬ç§»ï¼ˆMoveï¼‰**

rust

```rust
let s1 = String::from("hello");
let s2 = s1;  // æ‰€æœ‰æƒä» s1 è½¬ç§»åˆ° s2
// println!("{}", s1);  // âŒ é”™è¯¯ï¼s1 ä¸å†æœ‰æ•ˆ
println!("{}", s2);     // âœ… åªæœ‰ s2 èƒ½è®¿é—®æ•°æ®
```

### 2. What types are Copy?

**å“ªäº›ç±»å‹æ˜¯ Copy çš„ï¼Ÿ**

**Copy ç±»å‹**åœ¨èµ‹å€¼æ—¶ä¼šåˆ›å»º**å€¼çš„å‰¯æœ¬**ï¼Œè€Œä¸æ˜¯è½¬ç§»æ‰€æœ‰æƒã€‚

**Copy ç±»å‹åŒ…æ‹¬ï¼š**

- æ‰€æœ‰æ•´æ•°ç±»å‹ï¼š`i32`, `u64`, `usize` ç­‰
- æµ®ç‚¹æ•°ï¼š`f32`, `f64`
- å¸ƒå°”å€¼ï¼š`bool`
- å­—ç¬¦ï¼š`char`
- å…ƒç»„ï¼ˆå¦‚æœæ‰€æœ‰å…ƒç´ éƒ½æ˜¯ Copyï¼‰ï¼š`(i32, i32)`
- ä¸å¯å˜å¼•ç”¨ï¼š`&T`

**ç¤ºä¾‹ï¼šCopy ç±»å‹çš„è¡Œä¸º**

rust

```rust
let x = 5;
let y = x;  // å¤åˆ¶å€¼ï¼Œä¸æ˜¯è½¬ç§»æ‰€æœ‰æƒ
println!("{}, {}", x, y);  // âœ… x å’Œ y éƒ½æœ‰æ•ˆ
```

**é Copy ç±»å‹ï¼ˆOwnedï¼‰ï¼š**

- `String`ï¼ˆå †åˆ†é…çš„å­—ç¬¦ä¸²ï¼‰
- `Vec<T>`ï¼ˆåŠ¨æ€æ•°ç»„ï¼‰
- `Box<T>`ï¼ˆå †åˆ†é…çš„æŒ‡é’ˆï¼‰
- è‡ªå®šä¹‰ç»“æ„ä½“ï¼ˆé»˜è®¤ï¼‰

### 3. Can I make a new Copy type?

**æˆ‘èƒ½åˆ›å»ºæ–°çš„ Copy ç±»å‹å—ï¼Ÿ**

**å¯ä»¥ï¼Œä½†æœ‰æ¡ä»¶ï¼**

**ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° Copyï¼š**

rust

```rust
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

let p1 = Point { x: 1, y: 2 };
let p2 = p1;  // å¤åˆ¶ï¼Œä¸æ˜¯è½¬ç§»
println!("{}, {}", p1.x, p2.x);  // âœ… éƒ½æœ‰æ•ˆ
```

**é™åˆ¶æ¡ä»¶ï¼š** åªæœ‰å½“ç»“æ„ä½“çš„**æ‰€æœ‰å­—æ®µéƒ½æ˜¯ Copy** æ—¶ï¼Œæ‰èƒ½æ´¾ç”Ÿ `Copy`ï¼š

rust

```rust
// âŒ é”™è¯¯ï¼šä¸èƒ½ä¸ºåŒ…å« String çš„ç±»å‹å®ç° Copy
#[derive(Copy, Clone)]
struct Person {
    name: String,  // String ä¸æ˜¯ Copy
    age: i32,
}
```

rust

```rust
// âœ… æ­£ç¡®ï¼šæ‰€æœ‰å­—æ®µéƒ½æ˜¯ Copy
#[derive(Copy, Clone)]
struct Person {
    id: u32,      // u32 æ˜¯ Copy
    age: i32,     // i32 æ˜¯ Copy
}
```

## Owned vs Copy å¯¹æ¯”

| ç‰¹æ€§       | Owned ç±»å‹        | Copy ç±»å‹       |
| -------- | --------------- | ------------- |
| **èµ‹å€¼è¡Œä¸º** | è½¬ç§»æ‰€æœ‰æƒï¼ˆMoveï¼‰     | å¤åˆ¶å€¼           |
| **æ—§å˜é‡**  | èµ‹å€¼åå¤±æ•ˆ           | ä»ç„¶æœ‰æ•ˆ          |
| **æ€§èƒ½**   | æ— é¢å¤–å¼€é”€ï¼ˆåªè½¬ç§»æŒ‡é’ˆï¼‰    | å¯èƒ½æœ‰å¤åˆ¶å¼€é”€       |
| **å…¸å‹ä¾‹å­** | `String`, `Vec` | `i32`, `bool` |
| **å†…å­˜ä½ç½®** | é€šå¸¸åœ¨å †ä¸Š           | é€šå¸¸åœ¨æ ˆä¸Š         |




















è¿™å¼ å¹»ç¯ç‰‡ä»‹ç» **Cascading ownershipï¼ˆçº§è”æ‰€æœ‰æƒï¼‰** çš„æ¦‚å¿µã€‚

## ä»€ä¹ˆæ˜¯çº§è”æ‰€æœ‰æƒï¼Ÿ

**æ ¸å¿ƒæ¦‚å¿µï¼š** "If X owns Y and Y owns Z..."

- å¦‚æœ X æ‹¥æœ‰ Yï¼ŒY æ‹¥æœ‰ Z...
- é‚£ä¹ˆå½“ X è¢«é‡Šæ”¾æ—¶ï¼ŒY å’Œ Z ä¹Ÿä¼š**è‡ªåŠ¨çº§è”é‡Šæ”¾**

è¿™æ˜¯ Rust æ‰€æœ‰æƒç³»ç»Ÿçš„ä¸€ä¸ªé‡è¦ç‰¹æ€§ï¼š**æ‰€æœ‰æƒé“¾æ¡çš„ä¼ é€’æ€§**ã€‚

## ç¤ºä¾‹ï¼šStudent name

å¹»ç¯ç‰‡æåˆ°çš„ä¾‹å­æ˜¯"å­¦ç”Ÿå§“å"ï¼Œè®©æˆ‘ä»¬ç”¨ä»£ç è¯´æ˜ï¼š

rust

````rust
struct Student {
    name: String,        // Student æ‹¥æœ‰ String
    id: u32,
}

fn main() {
    let student = Student {
        name: String::from("Alice"),  // String æ‹¥æœ‰å †ä¸Šçš„ "Alice" æ•°æ®
        id: 12345,
    };
    
    // æ‰€æœ‰æƒé“¾æ¡ï¼š
    // student -> name (String) -> "Alice" (å †æ•°æ®)
    
} // student ç¦»å¼€ä½œç”¨åŸŸ
  // â†“ è‡ªåŠ¨é‡Šæ”¾ student
  // â†“ çº§è”é‡Šæ”¾ name (String)
  // â†“ çº§è”é‡Šæ”¾ "Alice" (å †æ•°æ®)
```

## çº§è”æ‰€æœ‰æƒçš„å·¥ä½œåŸç†

### å¯è§†åŒ–æ‰€æœ‰æƒæ ‘ï¼š
```
student (æ ˆä¸Š)
  â””â”€â”€ name: String (æ ˆä¸Šçš„æ™ºèƒ½æŒ‡é’ˆ)
       â””â”€â”€ "Alice" (å †ä¸Šçš„å®é™…æ•°æ®)
  â””â”€â”€ id: u32 (æ ˆä¸Š)
````

**å½“ `student` ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼š**

1. Rust è°ƒç”¨ `student` çš„ææ„å‡½æ•°ï¼ˆ`Drop`ï¼‰
2. `name` å­—æ®µè¢«é‡Šæ”¾ï¼Œè§¦å‘ `String` çš„ææ„å‡½æ•°
3. `String` é‡Šæ”¾å †ä¸Šçš„ `"Alice"` æ•°æ®
4. `id` å­—æ®µè¢«é‡Šæ”¾ï¼ˆCopy ç±»å‹ï¼Œç›´æ¥æ¸…ç©ºæ ˆå†…å­˜ï¼‰






**The perils of shared mutabilityï¼ˆå…±äº«å¯å˜æ€§çš„å±é™©ï¼‰**

å³ä¾§å¼•ç”¨äº† jashankj çš„åè¨€ï¼š

> **"Shared mutable state gonna hurt you!"**  
> ï¼ˆå…±äº«å¯å˜çŠ¶æ€ä¼šä¼¤å®³ä½ ï¼ï¼‰


## ä»€ä¹ˆæ˜¯ Shared Mutabilityï¼ˆå…±äº«å¯å˜æ€§ï¼‰ï¼Ÿ

**Shared mutability** æŒ‡çš„æ˜¯ï¼š

- **å¤šä¸ªåœ°æ–¹**å¯ä»¥è®¿é—®åŒä¸€æ•°æ®ï¼ˆSharedï¼‰
- **åŒæ—¶**è¿™äº›åœ°æ–¹å¯ä»¥ä¿®æ”¹æ•°æ®ï¼ˆMutableï¼‰

è¿™æ˜¯å¹¶å‘ç¼–ç¨‹å’Œç³»ç»Ÿå®‰å…¨ä¸­æœ€å±é™©çš„ç»„åˆï¼

## ä¸ºä»€ä¹ˆå®ƒå¾ˆå±é™©ï¼Ÿ

### é—®é¢˜ 1ï¼šæ•°æ®ç«äº‰ï¼ˆData Raceï¼‰

rust

```rust
// ä¼ªä»£ç ç¤ºä¾‹ï¼ˆè¿™åœ¨ Rust ä¸­æ— æ³•ç¼–è¯‘ï¼ï¼‰
let mut counter = 0;

// çº¿ç¨‹ 1
counter += 1;

// çº¿ç¨‹ 2ï¼ˆåŒæ—¶æ‰§è¡Œï¼‰
counter += 1;

// æœŸæœ›ç»“æœï¼š2
// å®é™…å¯èƒ½ï¼š1ï¼ˆå…¶ä¸­ä¸€æ¬¡å†™å…¥è¢«è¦†ç›–ï¼‰
```

**æ•°æ®ç«äº‰å‘ç”Ÿæ—¶ï¼š**

1. ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¯»å– `counter = 0`
2. ä¸¤ä¸ªçº¿ç¨‹éƒ½è®¡ç®— `0 + 1 = 1`
3. ä¸¤ä¸ªçº¿ç¨‹éƒ½å†™å…¥ `1`
4. ç»“æœé”™è¯¯ï¼š`counter = 1` è€Œä¸æ˜¯ `2`

### é—®é¢˜ 2ï¼šæ‚¬å‚æŒ‡é’ˆï¼ˆDangling Pointerï¼‰

c

```c
// C è¯­è¨€çš„å¸¸è§é”™è¯¯
char* get_name() {
    char buffer[20] = "Alice";
    return buffer;  // âŒ è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆï¼
}  // buffer è¢«é‡Šæ”¾ï¼Œä½†æŒ‡é’ˆä»åœ¨è¢«ä½¿ç”¨

char* name = get_name();
printf("%s", name);  // ğŸ’¥ è®¿é—®å·²é‡Šæ”¾çš„å†…å­˜ï¼
```

### é—®é¢˜ 3ï¼šè¿­ä»£å™¨å¤±æ•ˆ

cpp

```cpp
// C++ çš„ç»å…¸é—®é¢˜
std::vector<int> vec = {1, 2, 3, 4, 5};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    if (*it == 3) {
        vec.erase(it);  // âŒ åˆ é™¤å…ƒç´ ä½¿è¿­ä»£å™¨å¤±æ•ˆï¼
    }
}  // ğŸ’¥ æœªå®šä¹‰è¡Œä¸º
```

### é—®é¢˜ 4ï¼šå¹¶å‘ä¿®æ”¹å¼‚å¸¸

java

```java
// Java çš„å¸¸è§é”™è¯¯
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");

for (String s : list) {
    list.remove(s);  // âŒ ConcurrentModificationException!
}
```

## Rust å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ

Rust é€šè¿‡**å€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆBorrow Checkerï¼‰**åœ¨ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡Œä¸€æ¡é»„é‡‘æ³•åˆ™ï¼š

### ==**Rust çš„å€Ÿç”¨è§„åˆ™ï¼ˆæ ¸å¿ƒåŸåˆ™ï¼‰ï¼š**==

==**åœ¨ä»»ä½•ç»™å®šæ—¶é—´ï¼Œä½ åªèƒ½æ‹¥æœ‰ä»¥ä¸‹ä¹‹ä¸€ï¼š**==

1. ==**ä¸€ä¸ªå¯å˜å¼•ç”¨** (`&mut T`)==
2. ==**ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨** (`&T`)==

==ä½†**ç»ä¸èƒ½åŒæ—¶æ‹¥æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨**ï¼==

### ç¤ºä¾‹ 1ï¼šé˜²æ­¢æ•°æ®ç«äº‰

rust

```rust
let mut data = vec![1, 2, 3];

let r1 = &data;           // âœ… ä¸å¯å˜å¼•ç”¨
let r2 = &data;           // âœ… å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
println!("{:?}", r1);
println!("{:?}", r2);

let w = &mut data;        // âŒ ç¼–è¯‘é”™è¯¯ï¼
                          // ä¸èƒ½åœ¨æœ‰ä¸å¯å˜å¼•ç”¨æ—¶åˆ›å»ºå¯å˜å¼•ç”¨
```

### ç¤ºä¾‹ 2ï¼šé˜²æ­¢è¿­ä»£å™¨å¤±æ•ˆ

rust

```rust
let mut vec = vec![1, 2, 3, 4, 5];

for item in &vec {                  // ä¸å¯å˜å¼•ç”¨
    // vec.push(6);                 // âŒ ç¼–è¯‘é”™è¯¯ï¼
                                    // ä¸èƒ½åœ¨è¿­ä»£æ—¶ä¿®æ”¹
    println!("{}", item);
}  // ä¸å¯å˜å¼•ç”¨ç»“æŸ

vec.push(6);  // âœ… ç°åœ¨å¯ä»¥ä¿®æ”¹äº†
```

### ç¤ºä¾‹ 3ï¼šé˜²æ­¢æ‚¬å‚æŒ‡é’ˆ

rust

```rust
fn get_name() -> &str {
    let s = String::from("Alice");
    &s  // âŒ ç¼–è¯‘é”™è¯¯ï¼
}       // é”™è¯¯ï¼šè¿”å›å¯¹å±€éƒ¨å˜é‡çš„å¼•ç”¨
        // error: `s` does not live long enough
```

æ­£ç¡®çš„åšæ³•ï¼š

rust

````rust
fn get_name() -> String {
    String::from("Alice")  // âœ… è½¬ç§»æ‰€æœ‰æƒ
}
```

## å…±äº«å¯å˜æ€§çš„å¯è§†åŒ–
```
ä¼ ç»Ÿè¯­è¨€çš„é—®é¢˜ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®   â”‚ â† çº¿ç¨‹1 (è¯»/å†™)
â”‚ (å…±äº«)  â”‚ â† çº¿ç¨‹2 (è¯»/å†™)  ğŸ’¥ æ•°æ®ç«äº‰ï¼
â”‚ (å¯å˜)  â”‚ â† çº¿ç¨‹3 (è¯»/å†™)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Rust çš„è§£å†³æ–¹æ¡ˆï¼š
æ–¹æ¡ˆ1ï¼šå…±äº«ä½†ä¸å¯å˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®   â”‚ â† çº¿ç¨‹1 (åªè¯») âœ…
â”‚ (å…±äº«)  â”‚ â† çº¿ç¨‹2 (åªè¯») âœ… å®‰å…¨ï¼
â”‚(ä¸å¯å˜) â”‚ â† çº¿ç¨‹3 (åªè¯») âœ…
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ–¹æ¡ˆ2ï¼šå¯å˜ä½†ä¸å…±äº«
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®   â”‚ â† åªæœ‰ä¸€ä¸ªçº¿ç¨‹ (è¯»/å†™) âœ… å®‰å…¨ï¼
â”‚(ä¸å…±äº«) â”‚
â”‚ (å¯å˜)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
````











è¿™å¼ å¹»ç¯ç‰‡ä»‹ç» **Shared borrowsï¼ˆå…±äº«å€Ÿç”¨ï¼‰**ï¼Œå¹¶ç”¨ `shared.rs` ä½œä¸ºç¤ºä¾‹ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šè¿™æ®µä»£ç å±•ç¤ºçš„æ¦‚å¿µã€‚

## ä»€ä¹ˆæ˜¯ Shared Borrowsï¼Ÿ

**Shared borrowï¼ˆå…±äº«å€Ÿç”¨ï¼‰** = **ä¸å¯å˜å¼•ç”¨** (`&T`)

**æ ¸å¿ƒè§„åˆ™ï¼š**

- å¯ä»¥åŒæ—¶å­˜åœ¨**å¤šä¸ª**ä¸å¯å˜å¼•ç”¨
- ä½†ä¸èƒ½åŒæ—¶æœ‰å¯å˜å¼•ç”¨
- åªèƒ½è¯»å–æ•°æ®ï¼Œä¸èƒ½ä¿®æ”¹

## shared.rs ä»£ç åˆ†æ

rust

```rust
fn string_chars_len(string: &String) -> usize {
    string.chars().count()  // åªè¯»å–ï¼Œä¸ä¿®æ”¹
}
```

è¿™ä¸ªå‡½æ•°æ¥å— `&String`ï¼ˆå…±äº«å€Ÿç”¨/ä¸å¯å˜å¼•ç”¨ï¼‰ï¼Œè¿”å›å­—ç¬¦æ•°é‡ã€‚

### æµ‹è¯•ä»£ç å±•ç¤ºäº† Shared Borrows çš„ç‰¹æ€§

#### **æµ‹è¯• 1ï¼šå¤šæ¬¡å€Ÿç”¨åŒä¸€ä¸ªå­—ç¬¦ä¸²**

rust

```rust
#[test]
fn ascii() {
    let my_string = String::from("a");
    
    // ç¬¬ä¸€æ¬¡å€Ÿç”¨
    assert_eq!(string_chars_len(&my_string), 1);
    
    // my_string ä»ç„¶å¯ç”¨ï¼
    println!("{my_string}");
    
    // å¯ä»¥ç»§ç»­å¤šæ¬¡å€Ÿç”¨
    assert_eq!(string_chars_len(&String::from("ab")), 2);
    assert_eq!(string_chars_len(&String::from("abc")), 3);
    assert_eq!(string_chars_len(&String::from("abcd")), 4);
}
```

**å…³é”®ç‚¹ï¼š**

- `my_string` è¢«å€Ÿç”¨å**ä»ç„¶æœ‰æ•ˆ**
- å¯ä»¥**å¤šæ¬¡**ä¼ é€’ä¸å¯å˜å¼•ç”¨
- åŸå§‹æ‰€æœ‰è€…ï¼ˆ`my_string`ï¼‰ä»ç„¶å¯ä»¥è¯»å–æ•°æ®

#### **æµ‹è¯• 2ï¼šä¸´æ—¶å€¼çš„å€Ÿç”¨**

rust

```rust
#[test]
fn empty() {
    // åˆ›å»ºä¸´æ—¶ String å¹¶ç«‹å³å€Ÿç”¨
    assert_eq!(string_chars_len(&String::from("")), 0);
    // ä¸´æ—¶å€¼åœ¨è¿™ä¸€è¡Œç»“æŸåè¢«é‡Šæ”¾
}
```

#### **æµ‹è¯• 3ï¼šUnicode å­—ç¬¦å¤„ç†**

rust

```rust
#[test]
fn emoji() {
    // Rust æ­£ç¡®å¤„ç† Unicode å­—ç¬¦
    assert_eq!(string_chars_len(&String::from("ğŸ˜€ğŸ˜ƒğŸ˜„ğŸ˜ğŸ˜†")), 5);
    // 5 ä¸ª emoji = 5 ä¸ªå­—ç¬¦ï¼ˆä¸æ˜¯å­—èŠ‚æ•°ï¼ï¼‰
}
```

**æ³¨æ„ï¼š** `chars().count()` è¿”å› Unicode å­—ç¬¦æ•°ï¼Œä¸æ˜¯å­—èŠ‚æ•°ï¼š

rust

```rust
let s = String::from("ğŸ˜€");
println!("{}", s.len());         // 4 (å­—èŠ‚æ•°)
println!("{}", s.chars().count()); // 1 (å­—ç¬¦æ•°)
```

---

## Shared Borrows çš„è¯¦ç»†è§„åˆ™

### 1. **å¤šä¸ªä¸å¯å˜å¼•ç”¨å¯ä»¥å…±å­˜**

rust

```rust
let s = String::from("hello");

let r1 = &s;  // âœ… ç¬¬ä¸€ä¸ªä¸å¯å˜å¼•ç”¨
let r2 = &s;  // âœ… ç¬¬äºŒä¸ªä¸å¯å˜å¼•ç”¨
let r3 = &s;  // âœ… ç¬¬ä¸‰ä¸ªä¸å¯å˜å¼•ç”¨

println!("{}, {}, {}", r1, r2, r3);  // âœ… éƒ½å¯ä»¥ä½¿ç”¨
println!("{}", s);  // âœ… åŸå§‹æ‰€æœ‰è€…ä¹Ÿå¯ä»¥è¯»å–
```

**ä¸ºä»€ä¹ˆè¿™æ˜¯å®‰å…¨çš„ï¼Ÿ**

- æ‰€æœ‰å¼•ç”¨éƒ½åªèƒ½**è¯»å–**æ•°æ®
- æ²¡æœ‰äººä¿®æ”¹æ•°æ®
- ä¸ä¼šå‡ºç°æ•°æ®ç«äº‰

### 2. **ä¸å¯å˜å¼•ç”¨æœŸé—´ä¸èƒ½ä¿®æ”¹æ•°æ®**

rust

````rust
let mut s = String::from("hello");

let r1 = &s;  // âœ… ä¸å¯å˜å¼•ç”¨

s.push_str(" world");  // âŒ ç¼–è¯‘é”™è¯¯ï¼
                       // ä¸èƒ½åœ¨æœ‰ä¸å¯å˜å¼•ç”¨æ—¶ä¿®æ”¹æ•°æ®

println!("{}", r1);
```

**ç¼–è¯‘é”™è¯¯ä¿¡æ¯ï¼š**
```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
````

### 3. **å¼•ç”¨çš„ä½œç”¨åŸŸ**

rust

```rust
let mut s = String::from("hello");

let r1 = &s;
let r2 = &s;
println!("{}, {}", r1, r2);
// r1 å’Œ r2 çš„ä½œç”¨åŸŸåœ¨è¿™é‡Œç»“æŸï¼ˆæœ€åä¸€æ¬¡ä½¿ç”¨ï¼‰

s.push_str(" world");  // âœ… ç°åœ¨å¯ä»¥ä¿®æ”¹äº†
println!("{}", s);
```

**Rust çš„ Non-Lexical Lifetimes (NLL)ï¼š**

- å¼•ç”¨çš„ä½œç”¨åŸŸåˆ°**æœ€åä¸€æ¬¡ä½¿ç”¨**ä¸ºæ­¢
- ä¸æ˜¯åˆ°å£°æ˜çš„ä»£ç å—ç»“æŸ

---

## å¯¹æ¯”ï¼šShared vs Mutable Borrows

|ç‰¹æ€§|Shared Borrow (`&T`)|Mutable Borrow (`&mut T`)|
|---|---|---|
|**æ•°é‡**|å¯ä»¥æœ‰å¤šä¸ª|åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ª|
|**è¯»å–**|âœ… å¯ä»¥|âœ… å¯ä»¥|
|**ä¿®æ”¹**|âŒ ä¸å¯ä»¥|âœ… å¯ä»¥|
|**åŸå§‹æ‰€æœ‰è€…**|å¯ä»¥è¯»å–|ä¸èƒ½è®¿é—®|
|**å…¸å‹ç”¨é€”**|è¯»å–æ•°æ®ã€å¹¶è¡Œè¯»å–|ä¿®æ”¹æ•°æ®|

### ç¤ºä¾‹å¯¹æ¯”

**Shared Borrowï¼ˆæœ¬ä¾‹ï¼‰ï¼š**

rust

```rust
fn string_chars_len(string: &String) -> usize {
    string.chars().count()  // åªè¯»
}

let s = String::from("hello");
let len = string_chars_len(&s);  // å€Ÿç”¨
println!("{}", s);  // âœ… s ä»ç„¶å¯ç”¨
```

**Mutable Borrowï¼š**

rust

```rust
fn string_append(string: &mut String, suffix: &str) {
    string.push_str(suffix);  // ä¿®æ”¹
}

let mut s = String::from("hello");
string_append(&mut s, " world");  // å¯å˜å€Ÿç”¨
// println!("{}", s);  // âŒ å¦‚æœå¯å˜å¼•ç”¨è¿˜æ´»ç€ï¼Œè¿™ä¼šæŠ¥é”™
```

---

## ä¸ºä»€ä¹ˆéœ€è¦ Shared Borrowsï¼Ÿ

### 1. **æ•ˆç‡ï¼šé¿å…ä¸å¿…è¦çš„å¤åˆ¶**

**ä¸ç”¨å€Ÿç”¨ï¼ˆæ•ˆç‡ä½ï¼‰ï¼š**

rust

```rust
fn get_length(s: String) -> usize {  // è·å–æ‰€æœ‰æƒ
    s.len()
}  // s åœ¨è¿™é‡Œè¢«é‡Šæ”¾

let my_string = String::from("hello");
let len = get_length(my_string);  // my_string è¢«ç§»èµ°
// println!("{}", my_string);  // âŒ my_string å·²å¤±æ•ˆ
```

**ä½¿ç”¨å…±äº«å€Ÿç”¨ï¼ˆé«˜æ•ˆï¼‰ï¼š**

rust

```rust
fn get_length(s: &String) -> usize {  // å€Ÿç”¨
    s.len()
}

let my_string = String::from("hello");
let len = get_length(&my_string);  // åªæ˜¯å€Ÿç”¨
println!("{}", my_string);  // âœ… my_string ä»ç„¶å¯ç”¨
```

### 2. **å¹¶å‘å®‰å…¨ï¼šå¤šçº¿ç¨‹è¯»å–**

rust

```rust
use std::thread;
use std::sync::Arc;

let data = Arc::new(String::from("shared data"));

let mut handles = vec![];
for _ in 0..3 {
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        println!("{}", data);  // å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»å–
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
```

**è¿™æ˜¯å®‰å…¨çš„å› ä¸ºï¼š**

- æ‰€æœ‰çº¿ç¨‹åªæ˜¯**è¯»å–**æ•°æ®
- æ²¡æœ‰äººä¿®æ”¹æ•°æ®
- ä¸ä¼šå‘ç”Ÿæ•°æ®ç«äº‰

---

è¿™ä¸¤å¼ å¹»ç¯ç‰‡æ€»ç»“äº† **Shared borrowsï¼ˆå…±äº«å€Ÿç”¨/ä¸å¯å˜å¼•ç”¨ `&T`ï¼‰** çš„ç‰¹æ€§ã€‚

## Superpowersï¼ˆè¶…èƒ½åŠ›ï¼‰âœ…

**1. Can be shared infinitely many timesï¼ˆå¯ä»¥æ— é™æ¬¡å…±äº«ï¼‰**

rust

```rust
let s = String::from("hello");
let r1 = &s;
let r2 = &s;
let r3 = &s;
// ... å¯ä»¥æœ‰ä»»æ„å¤šä¸ªä¸å¯å˜å¼•ç”¨
```

**2. Very cheap to pass to fnsï¼ˆä¼ é€’ç»™å‡½æ•°éå¸¸ä¾¿å®œï¼‰**

rust

```rust
fn process(data: &String) { }  // åªä¼ é€’æŒ‡é’ˆï¼Œä¸å¤åˆ¶æ•°æ®
```

## Limitationsï¼ˆé™åˆ¶ï¼‰âŒ

**1. Cannot mutate data: read-onlyï¼ˆä¸èƒ½ä¿®æ”¹æ•°æ®ï¼šåªè¯»ï¼‰**

rust

```rust
let s = String::from("hello");
let r = &s;
// r.push_str(" world");  // âŒ ç¼–è¯‘é”™è¯¯
```

**2. Cannot take any exclusive borrows during its lifetimeï¼ˆåœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ä¸èƒ½æœ‰ç‹¬å å€Ÿç”¨ï¼‰**

rust

```rust
let mut s = String::from("hello");
let r1 = &s;           // å…±äº«å€Ÿç”¨
let r2 = &mut s;       // âŒ ä¸èƒ½åŒæ—¶æœ‰å¯å˜å€Ÿç”¨
println!("{}", r1);
```





è¿™å¼ å¹»ç¯ç‰‡ä»‹ç» **Exclusive borrowsï¼ˆç‹¬å å€Ÿç”¨/å¯å˜å¼•ç”¨ `&mut T`ï¼‰**ï¼Œç”¨ `exclusive.rs` ä½œä¸ºç¤ºä¾‹ã€‚

## ä»£ç åˆ†æ

rust

```rust
/// å°†å­—ç¬¦ä¸²è½¬ä¸ºå¤§å†™å¹¶æ·»åŠ  "!!!"
fn emphasize(string: &mut String) {
    string.make_ascii_uppercase();  // ä¿®æ”¹æ•°æ®
    string.push_str("!!!");         // ä¿®æ”¹æ•°æ®
}
```

## å…³é”®ç‰¹æ€§å±•ç¤º

### 1. **ç‹¬å å€Ÿç”¨å…è®¸ä¿®æ”¹**

rust

```rust
let mut s = String::from("hello");
emphasize(&mut s);  // å¯å˜å€Ÿç”¨
assert_eq!(s, "HELLO!!!");  // s è¢«ä¿®æ”¹äº†
```

### 2. **åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨**

rust

```rust
let mut s = String::from("aB");
let excl_borrow_1 = &mut s;  // ç¬¬ä¸€ä¸ªå¯å˜å€Ÿç”¨
emphasize(excl_borrow_1);    // ä½¿ç”¨è¿™ä¸ªå€Ÿç”¨
// excl_borrow_1 çš„ç”Ÿå‘½å‘¨æœŸç»“æŸ
assert_eq!(s, "AB!!!");      // ç°åœ¨å¯ä»¥è®¿é—® s
```

### 3. **åŸå§‹æ‰€æœ‰è€…åœ¨å¯å˜å€Ÿç”¨æœŸé—´ä¸å¯è®¿é—®**

rust

```rust
let mut s = String::from("test");
let r = &mut s;
// println!("{}", s);  // âŒ é”™è¯¯ï¼r è¿˜æ´»ç€
r.push_str("!");
println!("{}", r);     // r æœ€åä¸€æ¬¡ä½¿ç”¨
```

### 4. **å¯å˜å€Ÿç”¨ç»“æŸåå¯ä»¥å†æ¬¡å€Ÿç”¨**

rust

```rust
let mut s = String::from("aBc");
emphasize(&mut s);           // ç¬¬ä¸€æ¬¡å€Ÿç”¨
assert_eq!(s, "ABC!!!");     // å€Ÿç”¨ç»“æŸï¼Œå¯ä»¥è®¿é—®

let mut s = String::from("Hello, World!");
emphasize(&mut s);           // åˆä¸€æ¬¡æ–°çš„å€Ÿç”¨
assert_eq!(s, "HELLO, WORLD!!!!");
```

## æ ¸å¿ƒè§„åˆ™

**ç‹¬å å€Ÿç”¨ï¼ˆ`&mut T`ï¼‰çš„è§„åˆ™ï¼š**

- åŒä¸€æ—¶é—´åªèƒ½æœ‰**ä¸€ä¸ª**å¯å˜å¼•ç”¨
- åœ¨å¯å˜å¼•ç”¨å­˜åœ¨æ—¶ï¼Œ**ä¸èƒ½æœ‰**ä¸å¯å˜å¼•ç”¨
- åœ¨å¯å˜å¼•ç”¨å­˜åœ¨æ—¶ï¼ŒåŸå§‹æ‰€æœ‰è€…**ä¸èƒ½è®¿é—®**æ•°æ®

è¿™ç¡®ä¿äº†æ•°æ®ä¿®æ”¹çš„å®‰å…¨æ€§â€”â€”æ²¡æœ‰äººèƒ½åœ¨ä½ ä¿®æ”¹æ•°æ®æ—¶è¯»å–æˆ–ä¿®æ”¹å®ƒã€‚









è¿™å¼ å¹»ç¯ç‰‡æ€»ç»“äº† **Exclusive borrowsï¼ˆç‹¬å å€Ÿç”¨/å¯å˜å¼•ç”¨ `&mut T`ï¼‰** çš„ç‰¹æ€§ã€‚

## Superpowersï¼ˆè¶…èƒ½åŠ›ï¼‰âœ…

**1. Can mutate data without taking ownershipï¼ˆå¯ä»¥ä¿®æ”¹æ•°æ®è€Œä¸è·å–æ‰€æœ‰æƒï¼‰**

rust

```rust
fn modify(s: &mut String) {
    s.push_str("!");  // ä¿®æ”¹å€Ÿç”¨çš„æ•°æ®
}
let mut s = String::from("hello");
modify(&mut s);       // s ä»ç„¶æœ‰æ•ˆ
```

**2. Very cheap to pass to fnsï¼ˆä¼ é€’ç»™å‡½æ•°éå¸¸ä¾¿å®œï¼‰**

rust

```rust
fn process(data: &mut Vec<i32>) { }  // åªä¼ é€’æŒ‡é’ˆ
```

## Limitationsï¼ˆé™åˆ¶ï¼‰âŒ

**1. Cannot take any further exclusive borrows during its lifetimeï¼ˆåœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ä¸èƒ½æœ‰å…¶ä»–ç‹¬å å€Ÿç”¨ï¼‰**

rust

```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;  // âŒ é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰ä¸¤ä¸ªå¯å˜å¼•ç”¨
```

**2. Cannot take any shared borrows during its lifetimeï¼ˆåœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ä¸èƒ½æœ‰å…±äº«å€Ÿç”¨ï¼‰**

rust

```rust
let mut s = String::from("hello");
let r1 = &mut s;  // å¯å˜å¼•ç”¨
let r2 = &s;      // âŒ é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰ä¸å¯å˜å¼•ç”¨
```

**æ ¸å¿ƒï¼šåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œä¸”ä¸èƒ½ä¸ä¸å¯å˜å¼•ç”¨å…±å­˜ã€‚**








è¿™å¼ å¹»ç¯ç‰‡å±•ç¤º **Dangling referencesï¼ˆæ‚¬å‚å¼•ç”¨ï¼‰** çš„é—®é¢˜ï¼Œä»¥åŠ Rust å¦‚ä½•é˜²æ­¢å®ƒã€‚ä»£ç  `dangling.rs` æ¼”ç¤ºäº†æ­£ç¡®å’Œ"ç‹¡çŒ¾"çš„åšæ³•ã€‚

## ä»€ä¹ˆæ˜¯æ‚¬å‚å¼•ç”¨ï¼Ÿ

**æ‚¬å‚å¼•ç”¨**ï¼šæŒ‡å‘å·²è¢«é‡Šæ”¾å†…å­˜çš„å¼•ç”¨ã€‚åœ¨ C/C++ ä¸­å¾ˆå¸¸è§ï¼Œä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚

## dangling.rs ä»£ç åˆ†æ

### 1. **é”™è¯¯çš„å°è¯•ï¼ˆè¢«æ³¨é‡Šæ‰ï¼‰**

rust

```rust
fn create_linked_list(data: i32) -> &'static LinkedList {
    // let list = LinkedList {  // âŒ è¿™ä¼šåˆ›å»ºæ‚¬å‚å¼•ç”¨ï¼
    //     data,
    //     next: None,
    // };
    // &list  // é”™è¯¯ï¼šlist åœ¨å‡½æ•°ç»“æŸæ—¶è¢«é‡Šæ”¾
    &NODE  // âœ… æ­£ç¡®ï¼šè¿”å›é™æ€å˜é‡çš„å¼•ç”¨
}
```

**ä¸ºä»€ä¹ˆæ³¨é‡Šæ‰çš„ä»£ç ä¸èƒ½ç¼–è¯‘ï¼Ÿ**

rust

````rust
fn create_dangling() -> &'static LinkedList {
    let list = LinkedList { data: 42, next: None };
    &list  // âŒ ç¼–è¯‘é”™è¯¯ï¼šlist ä¸æ˜¯ 'static
}  // list åœ¨è¿™é‡Œè¢«é‡Šæ”¾ï¼Œè¿”å›çš„å¼•ç”¨æ‚¬å‚
```

**Rust ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š**
```
error[E0515]: cannot return reference to local variable `list`
  --> src/main.rs:X:Y
   |
   |     &list
   |     ^^^^^ returns a reference to data owned by the current function
````

### 2. **æ­£ç¡®çš„æ–¹æ³•ï¼šä½¿ç”¨é™æ€å˜é‡**

rust

```rust
static NODE: LinkedList = LinkedList {
    data: 42,
    next: None,
};

fn create_linked_list(data: i32) -> &'static LinkedList {
    &NODE  // âœ… NODE æ˜¯é™æ€çš„ï¼Œæ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½å­˜åœ¨
}
```

**ç‰¹ç‚¹ï¼š**

- `static` å˜é‡åœ¨ç¨‹åºè¿è¡ŒæœŸé—´ä¸€ç›´å­˜åœ¨
- ç”Ÿå‘½å‘¨æœŸæ˜¯ `'static`
- ä½†åªèƒ½è¿”å›å›ºå®šçš„ `NODE`ï¼Œä¸èƒ½ä½¿ç”¨ä¼ å…¥çš„ `data` å‚æ•°

### 3. **"ç‹¡çŒ¾"çš„æ–¹æ³•ï¼šBox::leak**

rust

```rust
fn create_linked_list_cheeky(data: i32) -> &'static LinkedList {
    let list = Box::new(LinkedList {  // åœ¨å †ä¸Šåˆ†é…
        data,
        next: None,
    });
    let leaked: &'static LinkedList = Box::leak(list);  // æ³„æ¼å†…å­˜
    leaked
}
```

**`Box::leak` çš„ä½œç”¨ï¼š**

- å°† `Box` ç®¡ç†çš„å†…å­˜"æ³„æ¼"å‡ºå»
- è¿”å› `'static` å¼•ç”¨
- **å†…å­˜æ°¸è¿œä¸ä¼šè¢«é‡Šæ”¾**ï¼ˆç›´åˆ°ç¨‹åºç»“æŸï¼‰

**ä¸ºä»€ä¹ˆå«"cheeky"ï¼ˆç‹¡çŒ¾ï¼‰ï¼Ÿ**

- æŠ€æœ¯ä¸Šæ˜¯åˆæ³•çš„
- ä½†æ¯æ¬¡è°ƒç”¨éƒ½ä¼š**æ°¸ä¹…æ³„æ¼å†…å­˜**
- ä¸æ¨èåœ¨å®é™…ä»£ç ä¸­ä½¿ç”¨ï¼ˆé™¤éç¡®å®éœ€è¦ï¼‰

## å¯¹æ¯”ï¼šC è¯­è¨€çš„æ‚¬å‚å¼•ç”¨

c

```c
// C è¯­è¨€ï¼šç¼–è¯‘é€šè¿‡ï¼Œä½†è¿è¡Œæ—¶å´©æºƒï¼
struct Node {
    int data;
    struct Node* next;
};

struct Node* create_node() {
    struct Node node = {42, NULL};
    return &node;  // âŒ è¿”å›æ ˆä¸Šå±€éƒ¨å˜é‡çš„åœ°å€ï¼
}  // node è¢«é‡Šæ”¾ï¼ŒæŒ‡é’ˆæ‚¬å‚

int main() {
    struct Node* n = create_node();
    printf("%d\n", n->data);  // ğŸ’¥ æœªå®šä¹‰è¡Œä¸ºï¼
}
```

**Rust çš„ä¼˜åŠ¿ï¼š**

- ç¼–è¯‘å™¨**åœ¨ç¼–è¯‘æ—¶**æ•è·æ‚¬å‚å¼•ç”¨
- ä¸ä¼šæœ‰è¿è¡Œæ—¶çš„æœªå®šä¹‰è¡Œä¸º

## ç”Ÿå‘½å‘¨æœŸ `'static`

rust

```rust
fn create_linked_list(data: i32) -> &'static LinkedList {
    //                              ^^^^^^^ 'static ç”Ÿå‘½å‘¨æœŸ
}
```

**`'static` çš„å«ä¹‰ï¼š**

- å¼•ç”¨åœ¨**æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´**éƒ½æœ‰æ•ˆ
- åªæœ‰ä»¥ä¸‹ä¸¤ç§æƒ…å†µå¯ä»¥è¿”å› `'static` å¼•ç”¨ï¼š
    1. æŒ‡å‘ `static` æˆ– `const` å˜é‡
    2. ä½¿ç”¨ `Box::leak` æ³„æ¼å†…å­˜

**å¸¸è§çš„ `'static` æ•°æ®ï¼š**

rust

```rust
let s: &'static str = "hello";  // å­—ç¬¦ä¸²å­—é¢é‡
static NUM: i32 = 42;            // é™æ€å˜é‡
const PI: f64 = 3.14;            // å¸¸é‡
```


## æ€»ç»“

|æ–¹æ³•|å®‰å…¨æ€§|çµæ´»æ€§|å†…å­˜ç®¡ç†|
|---|---|---|---|
|**æ³¨é‡Šæ‰çš„ä»£ç **|âŒ ç¼–è¯‘é”™è¯¯|-|-|
|**`&NODE`**|âœ… å®‰å…¨|âŒ åªèƒ½è¿”å›å›ºå®šå€¼|é™æ€å†…å­˜|
|**`Box::leak`**|âš ï¸ åˆæ³•ä½†ä¸æ¨è|âœ… å¯ä»¥ä½¿ç”¨å‚æ•°|æ°¸ä¹…æ³„æ¼|
|**è¿”å› `Box`**|âœ… æœ€ä½³å®è·µ|âœ… çµæ´»|æ­£å¸¸é‡Šæ”¾|

**å…³é”®è¦ç‚¹ï¼š**

- Rust ç¼–è¯‘å™¨é˜»æ­¢æ‚¬å‚å¼•ç”¨
- `'static` ç”Ÿå‘½å‘¨æœŸéœ€è¦æ•°æ®æ°¸ä¹…å­˜åœ¨
- é€šå¸¸åº”è¿”å› `Box` æˆ–ä½¿ç”¨æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œè€Œä¸æ˜¯å¼ºåˆ¶ä½¿ç”¨ `'static`