.unwrap()

- å¤„ç† Result ç±»å‹çš„æ–¹æ³•
- å¦‚æœæ“ä½œæˆåŠŸï¼šè¿”å›æˆåŠŸå€¼
- å¦‚æœæ“ä½œå¤±è´¥ï¼šç¨‹åºä¼š panicï¼ˆå´©æºƒï¼‰

æ¨¡å¼åŒ¹é…

img.save("img.bmp")

- è¿”å› Result ç±»å‹
- Result æœ‰ä¸¤ç§å¯èƒ½ï¼šOk(æˆåŠŸå€¼) æˆ– Err(é”™è¯¯å€¼)

match img.save("img.bmp") { Ok(_) => println!("ä¿å­˜æˆåŠŸ"), Err(e) => println!("ä¿å­˜å¤±è´¥: {}", e), }

è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨ Rust match è¯­å¥å¤„ç†æ¯”è¾ƒç»“æœçš„ä»£ç ç‰‡æ®µã€‚è®©æˆ‘è§£é‡Šä¸€ä¸‹ï¼š

ä»£ç ç»“æ„

rust

match x.cmp(y) { Ordering::LessThan => { img.set_pixel(x, y, ...); } Ordering::Equal => { img.set_pixel(x, y, ...); } Ordering::GreaterThan => { img.set_pixel(x, y, ...); } }

è¯¦ç»†è§£æ

1. x.cmp(y)

- cmp æ˜¯æ¯”è¾ƒæ–¹æ³•
- è¿”å› Ordering æšä¸¾ç±»å‹
- æ¯”è¾ƒ x å’Œ y çš„å¤§å°å…³ç³»

2. Ordering æšä¸¾çš„ä¸‰ç§å€¼

Ordering::LessThan

- å½“ x < y æ—¶åŒ¹é…
- æ‰§è¡Œç›¸åº”çš„åƒç´ è®¾ç½®

Ordering::Equal

- å½“ x == y æ—¶åŒ¹é…
- æ‰§è¡Œç›¸åº”çš„åƒç´ è®¾ç½®

Ordering::GreaterThan

- å½“ x > y æ—¶åŒ¹é…
- æ‰§è¡Œç›¸åº”çš„åƒç´ è®¾ç½®

1. cmp æ–¹æ³•çš„ç­¾å

rust

fn cmp(&self, other: &Self) -> Ordering

- cmp éœ€è¦ä¸€ä¸ªå¼•ç”¨ä½œä¸ºå‚æ•°
- ä¸æ˜¯è¦è·å– y çš„æ‰€æœ‰æƒï¼Œåªæ˜¯è¦æ¯”è¾ƒå€¼

letè¯­å¥ (let statements)

åœ¨Rustä¸­ï¼Œletè¯­å¥æ˜¯ç”¨æ¥åˆ›å»ºå˜é‡ç»‘å®šçš„ä¸»è¦æ–¹å¼ã€‚

> BINDINGSï¼ˆç»‘å®šï¼‰

rust

let x = 5; // åˆ›å»ºä¸€ä¸ªç»‘å®šï¼Œå°†å€¼5ç»‘å®šåˆ°åå­—xä¸Š let y = "hello"; // å°†å­—ç¬¦ä¸²"hello"ç»‘å®šåˆ°åå­—yä¸Š

åœ¨Rustä¸­ï¼Œæˆ‘ä»¬è¯´"ç»‘å®š"è€Œä¸æ˜¯"èµ‹å€¼"ï¼Œå› ä¸ºè¿™æ›´å‡†ç¡®åœ°æè¿°äº†å‘ç”Ÿçš„äº‹æƒ…ï¼š

- ç»‘å®šæ˜¯å°†ä¸€ä¸ªåå­—ä¸ä¸€ä¸ªå€¼å…³è”èµ·æ¥
- è¿™ä¸ªæ¦‚å¿µå¼ºè°ƒäº†æ‰€æœ‰æƒè½¬ç§»çš„é‡è¦æ€§

> MUTABILITYï¼ˆå¯å˜æ€§ï¼‰

Rustä¸­çš„ç»‘å®šé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼š

rust

let x = 5; x = 6; // âŒ ç¼–è¯‘é”™è¯¯ï¼ä¸èƒ½æ”¹å˜ä¸å¯å˜ç»‘å®š let mut y = 5; y = 6; // âœ… æ­£ç¡®ï¼ä½¿ç”¨mutå…³é”®å­—ä½¿ç»‘å®šå¯å˜

è¿™æ˜¯Rustå®‰å…¨æ€§çš„æ ¸å¿ƒç‰¹æ€§ï¼š

- é»˜è®¤ä¸å¯å˜é˜²æ­¢æ„å¤–ä¿®æ”¹
- å¿…é¡»æ˜¾å¼å£°æ˜mutæ‰èƒ½ä¿®æ”¹
- ç¼–è¯‘å™¨ä¼šå¼ºåˆ¶æ£€æŸ¥è¿™äº›è§„åˆ™

> SHADOWINGï¼ˆé®è”½ï¼‰

Rustå…è®¸ç”¨ç›¸åŒçš„åå­—åˆ›å»ºæ–°çš„ç»‘å®šï¼Œæ–°ç»‘å®šä¼š"é®è”½"æ—§çš„ï¼š

rust

let x = 5; let x = x + 1; // åˆ›å»ºæ–°ç»‘å®šï¼Œé®è”½äº†å‰ä¸€ä¸ªx let x = x * 2; // å†æ¬¡é®è”½ï¼Œç°åœ¨x = 12 // ç”šè‡³å¯ä»¥æ”¹å˜ç±»å‹ let spaces = " "; // å­—ç¬¦ä¸²ç±»å‹ let spaces = spaces.len(); // æ•°å­—ç±»å‹ï¼Œé®è”½äº†å‰é¢çš„å­—ç¬¦ä¸²

é®è”½ä¸å¯å˜æ€§çš„åŒºåˆ«ï¼š

- é®è”½åˆ›å»ºå…¨æ–°çš„ç»‘å®šï¼Œå¯ä»¥æ”¹å˜ç±»å‹
- å¯å˜æ€§åªæ˜¯ä¿®æ”¹ç°æœ‰ç»‘å®šçš„å€¼ï¼Œç±»å‹ä¸èƒ½æ”¹å˜

> ASIDE: CONSTANTSï¼ˆè¡¥å……ï¼šå¸¸é‡ï¼‰

å¸¸é‡ä¸letç»‘å®šçš„åŒºåˆ«ï¼š

rust

const MAX_POINTS: u32 = 100_000; // å¸¸é‡å£°æ˜ // åŒºåˆ«ï¼š // 1. å¿…é¡»ä½¿ç”¨constå…³é”®å­— // 2. å¿…é¡»æ ‡æ³¨ç±»å‹ // 3. åªèƒ½ç»‘å®šå¸¸é‡è¡¨è¾¾å¼ï¼Œä¸èƒ½æ˜¯å‡½æ•°è°ƒç”¨ç»“æœ // 4. åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆ // 5. æŒ‰æƒ¯ä¾‹ä½¿ç”¨å…¨å¤§å†™å­—æ¯å‘½å

Rustä¸­çš„ const

rust

const NUM_ROWS: i32 = 7 + 2; // Rustå¸¸é‡å®šä¹‰

Rust constçš„ç‰¹ç‚¹ï¼š

- ç±»å‹å®‰å…¨ï¼šå¿…é¡»æŒ‡å®šç±»å‹
- ç¼–è¯‘æ—¶æ±‚å€¼ï¼š7 + 2åœ¨ç¼–è¯‘æ—¶è®¡ç®—ä¸º9

C/C++ä¸­çš„ #define

#defineæ˜¯C/C++çš„é¢„å¤„ç†å™¨æŒ‡ä»¤ï¼Œç”¨äºåˆ›å»ºå®å®šä¹‰ï¼š

c

// C/C++ä»£ç  #define NUM_ROWS 7 + 2 // å®šä¹‰ä¸€ä¸ªå® int main() { int size = NUM_ROWS; // é¢„å¤„ç†å™¨ä¼šç›´æ¥æ›¿æ¢ä¸º: int size = 7 + 2; return 0; }

#defineçš„ç‰¹ç‚¹ï¼š

- æ–‡æœ¬æ›¿æ¢ï¼šé¢„å¤„ç†å™¨ç›´æ¥è¿›è¡Œå­—ç¬¦ä¸²æ›¿æ¢
- æ²¡æœ‰ç±»å‹æ£€æŸ¥ï¼šåªæ˜¯ç®€å•çš„æ–‡æœ¬æ›¿æ¢

åŸºæœ¬æ•°æ®ç±»å‹æ¦‚è§ˆã€‚

> INTEGER TYPES (FIXED, ARCH) - æ•´æ•°ç±»å‹ï¼ˆå›ºå®šä½æ•°ï¼Œæ¶æ„ç›¸å…³ï¼‰

å›ºå®šä½æ•°æ•´æ•°ç±»å‹ï¼š

æœ‰ç¬¦å·æ•´æ•° (å¯ä»¥è¡¨ç¤ºè´Ÿæ•°):

rust

let a: i8 = -128; // 8ä½ï¼ŒèŒƒå›´: -128 åˆ° 127 let b: i16 = -32768; // 16ä½ï¼ŒèŒƒå›´: -32,768 åˆ° 32,767 let c: i32 = -100; // 32ä½ï¼ŒèŒƒå›´: -2Â³Â¹ åˆ° 2Â³Â¹-1 (é»˜è®¤æ•´æ•°ç±»å‹) let d: i64 = -1000; // 64ä½ let e: i128 = -10000; // 128ä½

æ— ç¬¦å·æ•´æ•° (åªèƒ½è¡¨ç¤ºéè´Ÿæ•°):

rust

let a: u8 = 255; // 8ä½ï¼ŒèŒƒå›´: 0 åˆ° 255 let b: u16 = 65535; // 16ä½ï¼ŒèŒƒå›´: 0 åˆ° 65,535 let c: u32 = 100; // 32ä½ï¼ŒèŒƒå›´: 0 åˆ° 2Â³Â²-1 let d: u64 = 1000; // 64ä½ let e: u128 = 10000; // 128ä½

æ¶æ„ç›¸å…³æ•´æ•°ç±»å‹:

rust

let size: isize = -100; // æœ‰ç¬¦å·ï¼Œå¤§å°å–å†³äºç›®æ ‡æ¶æ„(32ä½æˆ–64ä½) let usize_val: usize = 100; // æ— ç¬¦å·ï¼Œé€šå¸¸ç”¨äºæ•°ç»„ç´¢å¼•å’Œå†…å­˜å¤§å°

æ•´æ•°å­—é¢é‡è¡¨ç¤ºï¼š

rust

let decimal = 98_222; // åè¿›åˆ¶ï¼Œå¯ç”¨ä¸‹åˆ’çº¿åˆ†éš” let hex = 0xff; // åå…­è¿›åˆ¶ let octal = 0o77; // å…«è¿›åˆ¶ let binary = 0b1111_0000; // äºŒè¿›åˆ¶ let byte = b'A'; // å­—èŠ‚å­—é¢é‡ (ä»…é™u8)

> FLOATING POINT TYPES - æµ®ç‚¹æ•°ç±»å‹

rust

let f1: f32 = 3.14; // 32ä½æµ®ç‚¹æ•° (å•ç²¾åº¦) let f2: f64 = 2.71828; // 64ä½æµ®ç‚¹æ•° (åŒç²¾åº¦ï¼Œé»˜è®¤æµ®ç‚¹ç±»å‹) // ç§‘å­¦è®¡æ•°æ³• let large = 1e6; // 1,000,000.0 let small = 1e-6; // 0.000001

æµ®ç‚¹æ•°è¿ç®—ï¼š

rust

let sum = 5.0 + 10.0; // åŠ æ³• let difference = 95.5 - 4.3; // å‡æ³• let product = 4.0 * 30.0; // ä¹˜æ³• let quotient = 56.7 / 32.2; // é™¤æ³• let remainder = 43.0 % 5.0; // å–ä½™

> BOOLEAN - å¸ƒå°”ç±»å‹

rust

let t: bool = true; // çœŸ let f: bool = false; // å‡ // å¸ƒå°”è¿ç®— let and_result = true && false; // é€»è¾‘ä¸: false let or_result = true || false; // é€»è¾‘æˆ–: true let not_result = !true; // é€»è¾‘é: false // æ¯”è¾ƒè¿ç®—è¿”å›å¸ƒå°”å€¼ let is_equal = 5 == 5; // true let is_greater = 10 > 5; // true

> CHARACTER - å­—ç¬¦ç±»å‹

rust

å››ä¸ªå­—èŠ‚ï¼Œä»»æ„utf8å­—ç¬¦

let c: char = 'z'; // åŸºæœ¬å­—ç¬¦ let heart = 'â¤'; // Unicodeå­—ç¬¦ let emoji = 'ğŸ˜€'; // è¡¨æƒ…ç¬¦å· let chinese = 'ä¸­'; // ä¸­æ–‡å­—ç¬¦ // å­—ç¬¦å 4ä¸ªå­—èŠ‚ï¼Œæ”¯æŒæ‰€æœ‰Unicodeæ ‡é‡å€¼ let unicode_char = '\u{1F600}'; // Unicodeè½¬ä¹‰åºåˆ—ï¼Œè¡¨ç¤ºğŸ˜€

ç±»å‹æ¨å¯¼å’Œæ˜¾å¼ç±»å‹æ³¨è§£

rust

// ç±»å‹æ¨å¯¼ let x = 42; // æ¨å¯¼ä¸º i32 let y = 3.14; // æ¨å¯¼ä¸º f64 let flag = true; // æ¨å¯¼ä¸º bool let letter = 'A'; // æ¨å¯¼ä¸º char // æ˜¾å¼ç±»å‹æ³¨è§£ let x: u8 = 42; let y: f32 = 3.14; // ç±»å‹åç¼€ let x = 42u8; // u8ç±»å‹ let y = 3.14f32; // f32ç±»å‹

ç±»å‹è½¬æ¢

rust

let integer = 42; let float = integer as f64; // æ˜¾å¼è½¬æ¢ let char_a = 'A'; let byte_value = char_a as u8; // å­—ç¬¦è½¬å­—èŠ‚ // å®‰å…¨è½¬æ¢æ–¹æ³• let big_number: u32 = 1000; let small_number: u8 = big_number.try_into().unwrap(); // å¯èƒ½å¤±è´¥çš„è½¬æ¢

å®é™…åº”ç”¨ç¤ºä¾‹

rust

fn main() { // è®¡ç®—å™¨ç¤ºä¾‹ let num1: f64 = 10.5; let num2: f64 = 2.0; let result = num1 / num2; println!("ç»“æœ: {}", result); // å­—ç¬¦å¤„ç† let grade: char = 'A'; let is_passing: bool = grade != 'F'; println!("æ˜¯å¦åŠæ ¼: {}", is_passing); // æ•°ç»„ç´¢å¼• let numbers = [1, 2, 3, 4, 5]; let index: usize = 2; println!("ç¬¬{}ä¸ªå…ƒç´ : {}", index, numbers[index]); }

è¿™äº›åŸºæœ¬ç±»å‹æ˜¯Rustç¨‹åºçš„æ„å»ºå—ï¼Œç†è§£å®ƒä»¬çš„ç‰¹æ€§å’Œä½¿ç”¨æ–¹æ³•å¯¹ç¼–å†™é«˜æ•ˆã€å®‰å…¨çš„Rustä»£ç éå¸¸é‡è¦ã€‚

Structï¼ˆç»“æ„ä½“ï¼‰

ç»“æ„ä½“ç”¨äºå°†ç›¸å…³çš„æ•°æ®ç»„åˆåœ¨ä¸€èµ·ï¼š

rust

struct Pixel { r: u8, // çº¢è‰²åˆ†é‡ (0-255) g: u8, // ç»¿è‰²åˆ†é‡ (0-255) b: u8, // è“è‰²åˆ†é‡ (0-255) }

ç»“æ„ä½“çš„ä½¿ç”¨

rust

// åˆ›å»ºç»“æ„ä½“å®ä¾‹ let red_pixel = Pixel { r: 255, g: 0, b: 0, }; // è®¿é—®å­—æ®µ println!("çº¢è‰²å€¼: {}", red_pixel.r); // å¯å˜ç»“æ„ä½“ let mut pixel = Pixel { r: 100, g: 150, b: 200 }; pixel.r = 255; // ä¿®æ”¹å­—æ®µå€¼

Enumï¼ˆæšä¸¾ï¼‰

æšä¸¾å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œå®ƒå¯ä»¥æ˜¯å‡ ä¸ªå¯èƒ½çš„å˜ä½“ä¹‹ä¸€ï¼š

rust

enum Color { Red, Green, Blue, }

æšä¸¾çš„ä½¿ç”¨

rust

// ä½¿ç”¨matchå¤„ç†æšä¸¾ fn describe_color(color: Color) -> String { match color { Color::Red => "çº¯çº¢è‰²".to_string(), Color::Green => "çº¯ç»¿è‰²".to_string(), Color::Blue => "çº¯è“è‰²".to_string(), } }

Optionæšä¸¾ï¼ˆæœ€å¸¸ç”¨çš„æšä¸¾ï¼‰

rust

enum Option<T> { Some(T), None, } // ä½¿ç”¨ç¤ºä¾‹ fn find_pixel(image: &[Pixel], target: Pixel) -> Option<usize> { for (index, pixel) in image.iter().enumerate() { if pixel.r == target.r && pixel.g == target.g && pixel.b == target.b { return Some(index); } } None } // å¤„ç†Option match find_pixel(&pixels, target_pixel) { Some(index) => println!("æ‰¾åˆ°åƒç´ ï¼Œä½ç½®: {}", index), None => println!("æœªæ‰¾åˆ°åŒ¹é…çš„åƒç´ "), }

ã€

1. HandSign æšä¸¾

rust

enum HandSign { ThumbsUp, ThumbsDown, }

è¯¦ç»†è§£é‡Šï¼š

- æšä¸¾å®šä¹‰ï¼šHandSign æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„æšä¸¾ç±»å‹
- å˜ä½“ï¼ˆVariantsï¼‰ï¼š

- ThumbsUp - è¡¨ç¤ºç«–èµ·å¤§æ‹‡æŒ‡ï¼ˆç‚¹èµæ‰‹åŠ¿ï¼‰
- ThumbsDown - è¡¨ç¤ºæ‹‡æŒ‡å‘ä¸‹ï¼ˆä¸èµåŒæ‰‹åŠ¿ï¼‰

- å•å…ƒå˜ä½“ï¼šè¿™ä¸¤ä¸ªå˜ä½“éƒ½ä¸æºå¸¦é¢å¤–æ•°æ®ï¼Œåªæ˜¯æ ‡è¯†ç¬¦

ç”¨æ³•ç¤ºä¾‹ï¼š

rust

let positive = HandSign::ThumbsUp; let negative = HandSign::ThumbsDown;

è¿™å¼ å›¾ç‰‡å±•ç¤ºäº†Rustä¸­æšä¸¾çš„å†…å­˜å¸ƒå±€å’Œå˜ä½“æ ‡è¯†ï¼Œè®©æˆ‘è¯¦ç»†è§£é‡Šï¼š

1. æšä¸¾å®šä¹‰è§£æ

rust

enum PossibleErrors { NothingToRead, // å•å…ƒå˜ä½“ RanOutOfSpace, // å•å…ƒå˜ä½“ NotImplemented, // å•å…ƒå˜ä½“ ErrorNumber(i32), // å…ƒç»„å˜ä½“ï¼ŒåŒ…å«i32 OtherError(String), // å…ƒç»„å˜ä½“ï¼ŒåŒ…å«String }

å˜ä½“ç±»å‹ï¼š

- å•å…ƒå˜ä½“ï¼šNothingToReadã€RanOutOfSpaceã€NotImplemented ä¸æºå¸¦æ•°æ®
- å…ƒç»„å˜ä½“ï¼šErrorNumber(i32)ã€OtherError(String) æºå¸¦æ•°æ®

2. å†…å­˜å¸ƒå±€è§£æ

å›¾ç‰‡ä¸‹æ–¹æ˜¾ç¤ºçš„æ˜¯æšä¸¾åœ¨å†…å­˜ä¸­çš„è¡¨ç¤ºï¼š

å†…å­˜ç»“æ„ï¼š

[which_variant] [some_data] 8bits max_bits

- which_variant (8 bits)ï¼šåˆ¤åˆ«å¼ï¼ˆdiscriminantï¼‰

- ç”¨æ¥æ ‡è¯†å½“å‰æšä¸¾å€¼æ˜¯å“ªä¸ªå˜ä½“
- 8ä½å¯ä»¥è¡¨ç¤º0-255ï¼Œè¶³å¤Ÿæ ‡è¯†è¿™5ä¸ªå˜ä½“

- some_data (max_bits)ï¼šæ•°æ®éƒ¨åˆ†

- å­˜å‚¨å˜ä½“æºå¸¦çš„å®é™…æ•°æ®
- å¤§å°ç­‰äºæ‰€æœ‰å˜ä½“ä¸­æœ€å¤§çš„é‚£ä¸ª

4. åˆ¤åˆ«å¼ï¼ˆDiscriminantï¼‰è¯¦è§£

4.1 ä»€ä¹ˆæ˜¯åˆ¤åˆ«å¼ï¼Ÿ

rust

// Rust å†…éƒ¨ä¸ºæ¯ä¸ªå˜ä½“åˆ†é…ä¸€ä¸ªæ•°å­—æ ‡è¯† PossibleErrors::NothingToRead // åˆ¤åˆ«å¼ = 0 PossibleErrors::RanOutOfSpace // åˆ¤åˆ«å¼ = 1 PossibleErrors::NotImplemented // åˆ¤åˆ«å¼ = 2 PossibleErrors::ErrorNumber(_) // åˆ¤åˆ«å¼ = 3 PossibleErrors::OtherError(_) // åˆ¤åˆ«å¼ = 4

4.2 ä¸ºä»€ä¹ˆéœ€è¦åˆ¤åˆ«å¼ï¼Ÿ

rust

let error = PossibleErrors::ErrorNumber(404); // å½“ä½ å†™ match æ—¶ï¼ŒRust éœ€è¦çŸ¥é“è¿™æ˜¯å“ªä¸ªå˜ä½“ match error { PossibleErrors::ErrorNumber(code) => { // Rust é€šè¿‡åˆ¤åˆ«å¼çŸ¥é“ï¼š // 1. è¿™ç¡®å®æ˜¯ ErrorNumber å˜ä½“ // 2. å¯ä»¥å®‰å…¨åœ°æŠŠæ•°æ®éƒ¨åˆ†è§£é‡Šä¸º i32 println!("é”™è¯¯ä»£ç : {}", code); } _ => {} }

![](assets/W1/file-20251127125736475.png)
![](assets/W1/file-20251127125813031.png)


è¿™æ˜¯ Rust ä¸­çš„ä¸€ä¸ªæ´¾ç”Ÿå®ï¼ˆderive macroï¼‰ï¼Œç”¨äºè‡ªåŠ¨ä¸ºç»“æ„ä½“æˆ–æšä¸¾å®ç°ç‰¹å®šçš„ traitã€‚

å…·ä½“æ¥è¯´ï¼š

- #[derive(...)] æ˜¯ Rust çš„å±æ€§å®è¯­æ³•
- Debug - è‡ªåŠ¨å®ç° Debug traitï¼Œå…è®¸ä½¿ç”¨ {:?} æˆ– {:#?} æ ¼å¼åŒ–æ‰“å°
- Clone - è‡ªåŠ¨å®ç° Clone traitï¼Œå…è®¸è°ƒç”¨ .clone() æ–¹æ³•åˆ›å»ºå‰¯æœ¬

fn ownership() { let x: Pixel = Pixel { r: 3, g: 5, b: 7 }; let mut y: Pixel = x; // x çš„æ‰€æœ‰æƒè½¬ç§»ç»™ y

y.r = 72; // ä¿®æ”¹ y çš„å­—æ®µ println!("{:?}", x); // âŒ å°è¯•ä½¿ç”¨å·²è¢«ç§»åŠ¨çš„ x }

fn ownership() {

let x: Pixel = Pixel { r: 3, g: 5, b: 7 }; let mut y: Pixel = x.clone(); // å…‹éš†è€Œä¸æ˜¯ç§»åŠ¨ y.r = 72; println!("{:?}", x); // âœ… x ä»ç„¶å¯ç”¨

}

ç®€å•çš„åŸºæœ¬ç±»å‹ä¼šè‡ªåŠ¨å¤åˆ¶ï¼Œå¤æ‚çš„ç±»å‹æ‰éœ€è¦æ˜¾å¼ cloneã€‚