åœ¨Rustä¸­ï¼Œ`let`è¯­å¥åˆ›å»ºçš„æ˜¯**ç»‘å®š**è€Œä¸æ˜¯ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„"å˜é‡"ã€‚è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µåŒºåˆ«ï¼š

rust

```rust
let x = 5;  // å°†å€¼5ç»‘å®šåˆ°åç§°xä¸Š
```

**å…³é”®ç‚¹ï¼š**

- ç»‘å®šæ„å‘³ç€å°†ä¸€ä¸ªå€¼ä¸ä¸€ä¸ªåç§°å…³è”èµ·æ¥
- è¿™ä½“ç°äº†Rustçš„æ‰€æœ‰æƒç³»ç»Ÿæ€æƒ³
- ç»‘å®šå¯ä»¥æ˜¯ä¸å¯å˜çš„ï¼ˆé»˜è®¤ï¼‰æˆ–å¯å˜çš„ï¼ˆä½¿ç”¨`mut`å…³é”®å­—ï¼‰

rust

```rust
let x = 10;        // ä¸å¯å˜ç»‘å®š
let mut y = 20;    // å¯å˜ç»‘å®š
y = 30;            // å¯ä»¥ä¿®æ”¹
```

## 2. MUTABILITYï¼ˆå¯å˜æ€§ï¼‰

Rustä¸­çš„ç»‘å®š**é»˜è®¤æ˜¯ä¸å¯å˜çš„**ï¼Œè¿™æ˜¯Rustå®‰å…¨æ€§è®¾è®¡çš„æ ¸å¿ƒç‰¹æ€§ï¼š

rust

```rust
let x = 5;
x = 6;  // âŒ é”™è¯¯ï¼xæ˜¯ä¸å¯å˜çš„

let mut y = 5;
y = 6;  // âœ… æ­£ç¡®ï¼yæ˜¯å¯å˜çš„
```

**è®¾è®¡ç†å¿µï¼š**

- ä¸å¯å˜æ€§æ˜¯é»˜è®¤çš„ï¼Œé¼“åŠ±æ›´å®‰å…¨çš„ä»£ç 
- éœ€è¦å¯å˜æ€§æ—¶å¿…é¡»æ˜¾å¼å£°æ˜`mut`
- è¿™å¸®åŠ©é˜²æ­¢æ„å¤–ä¿®æ”¹æ•°æ®
- ä½¿ä»£ç æ›´å®¹æ˜“æ¨ç†å’Œç»´æŠ¤

## 3. SHADOWINGï¼ˆé®è”½ï¼‰

Shadowingå…è®¸ä½ ç”¨ç›¸åŒçš„åç§°å£°æ˜æ–°çš„ç»‘å®šï¼Œ**é®è”½**ä¹‹å‰çš„ç»‘å®šï¼š

rust

```rust
let x = 5;
let x = x + 1;     // åˆ›å»ºæ–°çš„xï¼Œé®è”½äº†æ—§çš„x
let x = x * 2;     // å†æ¬¡é®è”½
println!("{}", x); // è¾“å‡º: 12
```

**Shadowing vs å¯å˜æ€§çš„åŒºåˆ«ï¼š**

rust

```rust
// Shadowing - å¯ä»¥æ”¹å˜ç±»å‹
let spaces = "   ";
let spaces = spaces.len();  // âœ… ä»&strå˜ä¸ºusize

// å¯å˜æ€§ - ä¸èƒ½æ”¹å˜ç±»å‹
let mut spaces = "   ";
spaces = spaces.len();      // âŒ é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
```

**Shadowingçš„ä¼˜åŠ¿ï¼š**

- å¯ä»¥æ”¹å˜å€¼çš„ç±»å‹
- å¯ä»¥é‡ç”¨å˜é‡å
- æ¯æ¬¡shadowingéƒ½åˆ›å»ºæ–°çš„ä¸å¯å˜ç»‘å®š
- åœ¨ä¸åŒä½œç”¨åŸŸä¸­å¯ä»¥æœ‰ä¸åŒçš„å«ä¹‰

## 4. ASIDE: CONSTANTSï¼ˆè¡¥å……ï¼šå¸¸é‡ï¼‰

å¸¸é‡ä¸ä¸å¯å˜ç»‘å®šæœ‰é‡è¦åŒºåˆ«ï¼š

rust

```rust
const MAX_POINTS: u32 = 100_000;
```

**å¸¸é‡çš„ç‰¹ç‚¹ï¼š**

- ä½¿ç”¨`const`å…³é”®å­—å£°æ˜
- **å¿…é¡»æ ‡æ³¨ç±»å‹**
- å¿…é¡»åœ¨ç¼–è¯‘æ—¶å°±èƒ½ç¡®å®šå€¼
- å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
- å‘½åçº¦å®šï¼šå…¨å¤§å†™å­—æ¯ï¼Œä¸‹åˆ’çº¿åˆ†éš”

---

**æ€»ç»“ï¼š** è¿™å››ä¸ªæ¦‚å¿µå…±åŒæ„æˆäº†Rustå˜é‡ç³»ç»Ÿçš„åŸºç¡€ã€‚ç»‘å®šå¼ºè°ƒæ‰€æœ‰æƒï¼Œé»˜è®¤ä¸å¯å˜æ€§ä¿è¯å®‰å…¨ï¼Œshadowingæä¾›çµæ´»æ€§ï¼Œè€Œå¸¸é‡æä¾›çœŸæ­£çš„ç¼–è¯‘æ—¶å¸¸é‡ã€‚è¿™äº›è®¾è®¡ä½¿Rustæ—¢å®‰å…¨åˆçµæ´»ã€‚






## 1. INTEGER TYPESï¼ˆæ•´æ•°ç±»å‹ - FIXED, ARCHï¼‰

Rustæä¾›äº†å¤šç§æ•´æ•°ç±»å‹ï¼Œåˆ†ä¸º**å›ºå®šå¤§å°ç±»å‹**å’Œ**æ¶æ„ç›¸å…³ç±»å‹**ã€‚

### å›ºå®šå¤§å°æ•´æ•°ç±»å‹ï¼ˆFixed-sizeï¼‰

**æœ‰ç¬¦å·æ•´æ•°ï¼ˆsignedï¼‰ï¼š** å¯ä»¥è¡¨ç¤ºæ­£æ•°ã€è´Ÿæ•°å’Œé›¶

|ç±»å‹|å¤§å°|èŒƒå›´|
|---|---|---|
|`i8`|8ä½|-128 åˆ° 127|
|`i16`|16ä½|-32,768 åˆ° 32,767|
|`i32`|32ä½|-2,147,483,648 åˆ° 2,147,483,647|
|`i64`|64ä½|-9,223,372,036,854,775,808 åˆ° 9,223,372,036,854,775,807|
|`i128`|128ä½|éå¸¸å¤§çš„èŒƒå›´|

**æ— ç¬¦å·æ•´æ•°ï¼ˆunsignedï¼‰ï¼š** åªèƒ½è¡¨ç¤ºéè´Ÿæ•°

|ç±»å‹|å¤§å°|èŒƒå›´|
|---|---|---|
|`u8`|8ä½|0 åˆ° 255|
|`u16`|16ä½|0 åˆ° 65,535|
|`u32`|32ä½|0 åˆ° 4,294,967,295|
|`u64`|64ä½|0 åˆ° 18,446,744,073,709,551,615|
|`u128`|128ä½|éå¸¸å¤§çš„èŒƒå›´|

**ç¤ºä¾‹ä»£ç ï¼š**

rust

```rust
// æ•´æ•°å­—é¢é‡å¯ä»¥ä½¿ç”¨ç±»å‹åç¼€
let x = 42u8;               // u8ç±»å‹
let y = 100i32;             // i32ç±»å‹
```

### æ¶æ„ç›¸å…³ç±»å‹ï¼ˆArchitecture-dependentï¼‰

|ç±»å‹|è¯´æ˜|
|---|---|
|`isize`|æœ‰ç¬¦å·ï¼Œå¤§å°å–å†³äºCPUæ¶æ„ï¼ˆ32ä½ç³»ç»Ÿä¸Šæ˜¯32ä½ï¼Œ64ä½ç³»ç»Ÿä¸Šæ˜¯64ä½ï¼‰|
|`usize`|æ— ç¬¦å·ï¼Œå¤§å°å–å†³äºCPUæ¶æ„|

æŒ‡é’ˆè¿ç®—å’Œå†…å­˜åœ°å€ä½¿ç”¨isize/usize



---

## 2. FLOATING POINT TYPESï¼ˆæµ®ç‚¹æ•°ç±»å‹ï¼‰

Rustæœ‰ä¸¤ç§æµ®ç‚¹æ•°ç±»å‹ï¼Œéƒ½æ˜¯**æœ‰ç¬¦å·**çš„ï¼š

|ç±»å‹|å¤§å°|ç²¾åº¦|
|---|---|---|
|`f32`|32ä½|å•ç²¾åº¦|
|`f64`|64ä½|åŒç²¾åº¦ï¼ˆé»˜è®¤ï¼‰|


**æ³¨æ„äº‹é¡¹ï¼š**

rust

```rust
// æµ®ç‚¹æ•°æ¯”è¾ƒè¦å°å¿ƒ
let a = 0.1 + 0.2;
let b = 0.3;
// a == b å¯èƒ½æ˜¯falseï¼Œå› ä¸ºæµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜

// æ¨èä½¿ç”¨epsilonæ¯”è¾ƒ
let epsilon = 0.00001;
if (a - b).abs() < epsilon {
    println!("è¿‘ä¼¼ç›¸ç­‰");
}
```

---

## 3. BOOLEANï¼ˆå¸ƒå°”ç±»å‹ï¼‰

å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`ï¼Œå ç”¨**1ä¸ªå­—èŠ‚**ã€‚

rust

```rust
let t: bool = true;
let f: bool = false;

// å¸¸ç”¨äºæ¡ä»¶åˆ¤æ–­
if t {
    println!("è¿™æ˜¯çœŸçš„ï¼");
}

// å¸ƒå°”è¿ç®—
let and = true && false;    // false
let or = true || false;     // true
let not = !true;            // false

// æ¯”è¾ƒè¿ç®—è¿”å›å¸ƒå°”å€¼
let greater = 5 > 3;        // true
let equal = 5 == 5;         // true
```

---

## 4. CHARACTERï¼ˆå­—ç¬¦ç±»å‹ï¼‰

Rustçš„`char`ç±»å‹ä»£è¡¨ä¸€ä¸ª**Unicodeæ ‡é‡å€¼**ï¼Œå ç”¨**4ä¸ªå­—èŠ‚**ã€‚

rust

```rust
let c: char = 'z';
let z: char = 'â„¤';
let heart_eyed_cat: char = 'ğŸ˜»';
let chinese: char = 'ä¸­';

// æ³¨æ„ï¼šcharä½¿ç”¨å•å¼•å·ï¼Œå­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å·
let character = 'A';    // char
let string = "A";       // &str
```



---

## ç±»å‹æ¨æ–­ä¸æ˜¾å¼æ ‡æ³¨

Rustæœ‰å¼ºå¤§çš„ç±»å‹æ¨æ–­èƒ½åŠ›ï¼š

rust

```rust
// ç±»å‹æ¨æ–­
let x = 5;          // ç¼–è¯‘å™¨æ¨æ–­ä¸ºi32
let y = 2.0;        // ç¼–è¯‘å™¨æ¨æ–­ä¸ºf64

// æ˜¾å¼ç±»å‹æ ‡æ³¨
let a: i64 = 5;
let b: f32 = 2.0;
let c: bool = true;
let d: char = 'x';

// ä¸Šä¸‹æ–‡å¸®åŠ©æ¨æ–­
let mut vec = Vec::new();
vec.push(1);        // ç¼–è¯‘å™¨æ¨æ–­vecæ˜¯Vec<i32>
```








## 1. TUPLES, ARRAYSï¼ˆå…ƒç»„å’Œæ•°ç»„ï¼‰

### å…ƒç»„ï¼ˆTuplesï¼‰

å…ƒç»„æ˜¯å°†**å¤šä¸ªä¸åŒç±»å‹**çš„å€¼ç»„åˆæˆä¸€ä¸ªå¤åˆç±»å‹çš„æ–¹å¼ã€‚

**åŸºæœ¬è¯­æ³•ï¼š**

rust

```rust
// åˆ›å»ºå…ƒç»„
let tup: (i32, f64, u8) = (500, 6.4, 1);

// è§£æ„å…ƒç»„
let (x, y, z) = tup;
println!("y çš„å€¼æ˜¯: {}", y);  // è¾“å‡º: 6.4

// é€šè¿‡ç´¢å¼•è®¿é—®
let five_hundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;
```

**å…ƒç»„çš„ç‰¹ç‚¹ï¼š**

rust

```rust
// å›ºå®šé•¿åº¦ï¼Œåˆ›å»ºåä¸èƒ½æ”¹å˜å¤§å°
let tuple = (1, 2, 3);

// å¯ä»¥åŒ…å«ä¸åŒç±»å‹
let mixed = (42, "hello", 3.14, true);

// å¯ä»¥åµŒå¥—
let nested = ((1, 2), (3, 4));

// ç©ºå…ƒç»„ç§°ä¸ºunitï¼Œå†™ä½œ ()
let unit = ();
```

**å®é™…åº”ç”¨ï¼š**

rust

```rust
// å‡½æ•°è¿”å›å¤šä¸ªå€¼
fn calculate(x: i32) -> (i32, i32, i32) {
    (x + 1, x * 2, x * x)
}

fn main() {
    let (add, mul, square) = calculate(5);
    println!("åŠ 1: {}, ä¹˜2: {}, å¹³æ–¹: {}", add, mul, square);
}

// äº¤æ¢ä¸¤ä¸ªå€¼
let mut a = 1;
let mut b = 2;
(a, b) = (b, a);  // äº¤æ¢
```

### æ•°ç»„ï¼ˆArraysï¼‰

æ•°ç»„æ˜¯**å›ºå®šé•¿åº¦**ã€**ç›¸åŒç±»å‹**å…ƒç´ çš„é›†åˆã€‚

**åŸºæœ¬è¯­æ³•ï¼š**

rust

```rust
// åˆ›å»ºæ•°ç»„
let arr: [i32; 5] = [1, 2, 3, 4, 5];

// ç®€å†™ï¼šæ‰€æœ‰å…ƒç´ ç›¸åŒ
let arr = [3; 5];  // ç­‰åŒäº [3, 3, 3, 3, 3]

// è®¿é—®å…ƒç´ 
let first = arr[0];
let second = arr[1];
```

**æ•°ç»„çš„ç‰¹ç‚¹ï¼š**

rust

```rust
// å›ºå®šé•¿åº¦ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
let months = ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", 
              "å…­æœˆ", "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", 
              "åä¸€æœˆ", "åäºŒæœˆ"];

// ç±»å‹æ ‡æ³¨ï¼š[ç±»å‹; é•¿åº¦]
let numbers: [i32; 3] = [1, 2, 3];

// è·å–é•¿åº¦
let len = numbers.len();  // 3
```

**æ•°ç»„è¶Šç•Œæ£€æŸ¥ï¼š**

rust

```rust
let arr = [1, 2, 3, 4, 5];

// è¿è¡Œæ—¶ä¼španic
// let element = arr[10];  // ç´¢å¼•è¶Šç•Œï¼

// å®‰å…¨è®¿é—®
if let Some(value) = arr.get(2) {
    println!("å€¼æ˜¯: {}", value);
}
```

**æ•°ç»„éå†ï¼š**

rust

```rust
let arr = [10, 20, 30, 40, 50];

// æ–¹æ³•1ï¼šforå¾ªç¯
for element in arr {
    println!("å€¼: {}", element);
}

// æ–¹æ³•2ï¼šå¸¦ç´¢å¼•
for (index, value) in arr.iter().enumerate() {
    println!("ç´¢å¼• {}: å€¼ {}", index, value);
}
```

---

## 2. STRUCTS, ENUMSï¼ˆç»“æ„ä½“å’Œæšä¸¾ï¼‰

### ç»“æ„ä½“ï¼ˆStructsï¼‰

ç»“æ„ä½“ç”¨äºåˆ›å»º**è‡ªå®šä¹‰æ•°æ®ç±»å‹**ï¼Œå°†ç›¸å…³æ•°æ®ç»„åˆåœ¨ä¸€èµ·ã€‚

**ä¸‰ç§ç»“æ„ä½“ç±»å‹ï¼š**

**1. å‘½åå­—æ®µç»“æ„ä½“ï¼š**

rust

```rust
// å®šä¹‰ç»“æ„ä½“
struct User {
    username: String,
    email: String,
    age: u32,
    active: bool,
}

// åˆ›å»ºå®ä¾‹
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("å¼ ä¸‰"),
    age: 25,
    active: true,
};

// è®¿é—®å­—æ®µ
println!("ç”¨æˆ·å: {}", user1.username);

// å¯å˜å®ä¾‹
let mut user2 = User {
    email: String::from("another@example.com"),
    username: String::from("æå››"),
    age: 30,
    active: true,
};
user2.age = 31;  // ä¿®æ”¹å­—æ®µ
```

**2. å…ƒç»„ç»“æ„ä½“ï¼š**

rust

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// è®¿é—®å­—æ®µ
println!("çº¢è‰²å€¼: {}", black.0);
```

**3. å•å…ƒç»“æ„ä½“ï¼ˆæ— å­—æ®µï¼‰ï¼š**

rust

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;
```

**ç»“æ„ä½“æ–¹æ³•ï¼š**

rust

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•ï¼ˆéœ€è¦selfï¼‰
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // å…³è”å‡½æ•°ï¼ˆä¸éœ€è¦selfï¼‰
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    println!("é¢ç§¯: {}", rect.area());
    
    let sq = Rectangle::square(20);
}
```

### æšä¸¾ï¼ˆEnumsï¼‰

æšä¸¾å…è®¸ä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œå®ƒçš„å€¼å¯ä»¥æ˜¯**å‡ ä¸ªå˜ä½“ä¹‹ä¸€**ã€‚

**åŸºæœ¬æšä¸¾ï¼š**

rust

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

let direction = Direction::North;
```

**å¸¦æ•°æ®çš„æšä¸¾ï¼š**

rust

```rust
enum Message {
    Quit,                       // æ— æ•°æ®
    Move { x: i32, y: i32 },   // å‘½åå­—æ®µ
    Write(String),              // å•ä¸ªå€¼
    ChangeColor(i32, i32, i32), // å…ƒç»„
}

let msg1 = Message::Quit;
let msg2 = Message::Move { x: 10, y: 20 };
let msg3 = Message::Write(String::from("hello"));
let msg4 = Message::ChangeColor(255, 0, 0);
```

**Optionæšä¸¾ï¼ˆæœ€é‡è¦çš„æšä¸¾ä¹‹ä¸€ï¼‰ï¼š**
è¡¨ç¤ºâ€œå¯èƒ½æœ‰å€¼ / å¯èƒ½æ²¡å€¼â€çš„ç±»å‹
rust

```rust
enum Option<T> {
    Some(T),
    None,
}

// ä½¿ç”¨Optionå¤„ç†å¯èƒ½ä¸å­˜åœ¨çš„å€¼
let some_number = Some(5);
let some_string = Some("å­—ç¬¦ä¸²");
let absent_number: Option<i32> = None;

// ä½¿ç”¨matchå¤„ç†
match some_number {
    Some(value) => println!("å€¼æ˜¯: {}", value),
    None => println!("æ²¡æœ‰å€¼"),
}
```

**Resultæšä¸¾ï¼ˆé”™è¯¯å¤„ç†ï¼‰ï¼š**

rust

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("é™¤æ•°ä¸èƒ½ä¸ºé›¶"))
    } else {
        Ok(a / b)
    }
}

match divide(10, 2) {
    Ok(result) => println!("ç»“æœ: {}", result),
    Err(err) => println!("é”™è¯¯: {}", err),
}
```

**æšä¸¾æ–¹æ³•ï¼š**

rust

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

impl TrafficLight {
    fn time(&self) -> u32 {
        match self {
            TrafficLight::Red => 60,
            TrafficLight::Yellow => 3,
            TrafficLight::Green => 90,
        }
    }
}

let light = TrafficLight::Red;
println!("æ—¶é•¿: {} ç§’", light.time());
```

---

## 3. ASIDE: PERVASIVE MUTABILITYï¼ˆè¡¥å……ï¼šæ™®éå¯å˜æ€§ï¼‰

åœ¨å¾ˆå¤šè¯­è¨€é‡Œï¼Œæ‰€æœ‰æ•°æ®éƒ½é»˜è®¤æ˜¯å¯å˜çš„ï¼Œå¯¼è‡´ bug éš¾ä»¥è¿½è¸ªï¼ŒçŠ¶æ€éš¾ä»¥ç®¡ç†ã€‚
Rust çš„è®¾è®¡ç›®æ ‡ï¼Œå°±æ˜¯è®©å¯å˜æ€§å˜å¾—å—æ§ã€æ˜¾å¼ã€å¯éªŒè¯ã€‚
rustå¦‚ä½•è§£å†³çš„å‘¢ï¼š
é»˜è®¤ä¸å¯å˜ï¼ˆimmutable by defaultï¼‰
åŒæ—¶åªèƒ½ï¼š

å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼ˆ&Tï¼‰
    
æˆ– 1 ä¸ªå¯å˜å¼•ç”¨ï¼ˆ&mut Tï¼‰


---

## 4. ASIDE: UNITï¼ˆè¡¥å……ï¼šå•å…ƒç±»å‹ï¼‰

**å•å…ƒç±»å‹ `()`ï¼š**

å•å…ƒç±»å‹æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ï¼Œåªæœ‰ä¸€ä¸ªå€¼ï¼Œä¹Ÿå†™ä½œ `()`ã€‚

**ç”¨é€”ï¼š**

rust

```rust
// 1. æ— è¿”å›å€¼çš„å‡½æ•°
fn do_something() -> () {
    println!("åšäº›äº‹æƒ…");
    // éšå¼è¿”å› ()
}

// ç­‰åŒäº
fn do_something() {
    println!("åšäº›äº‹æƒ…");
}

// 2. åœ¨æ³›å‹ä¸­ä½œä¸ºå ä½ç¬¦
let empty_tuple = ();

// 3. è¡¨ç¤º"æ— æ„ä¹‰"çš„å€¼
let result: Result<(), String> = Ok(());

// 4. æ•°ç»„å’Œå‘é‡
let empty_array: [(); 0] = [];
```


---

**è¡¨è¾¾å¼ï¼ˆExpressionï¼‰ä¸è¯­å¥ï¼ˆStatementï¼‰**çš„åŒºåˆ«ï¼š


1. VALUE PRODUCTIONï¼ˆå€¼çš„äº§ç”Ÿï¼‰
è¡¨è¾¾å¼ï¼šæ²¡æœ‰åˆ†å·ï¼Œä¼šè¿”å›å€¼
è¯­å¥ï¼šæœ‰åˆ†å·ï¼Œä¸è¿”å›å€¼

## 2. IMPLICATIONS ON NESTINGï¼ˆå¯¹åµŒå¥—çš„å½±å“ï¼‰

è¡¨è¾¾å¼å¯ä»¥åµŒå¥—ï¼Œè€Œè¯­å¥ä¸èƒ½ä½œä¸ºå€¼ä½¿ç”¨ã€‚
## 3. ITEM DECLARATIONSï¼ˆé¡¹å£°æ˜ï¼‰

é¡¹ï¼ˆItemsï¼‰æ˜¯åœ¨æ¨¡å—çº§åˆ«å®šä¹‰çš„ç»„ä»¶ï¼ŒåŒ…æ‹¬ï¼š
## 4. LET STATEMENTSï¼ˆletè¯­å¥ï¼‰

`let`è¯­å¥ç”¨äºåˆ›å»ºç»‘å®šï¼Œæ˜¯ä¸€ç§è¯­å¥ï¼Œä¸è¿”å›å€¼ã€‚

## 5. EXPRESSION STATEMENTSï¼ˆè¡¨è¾¾å¼è¯­å¥ï¼‰

è¡¨è¾¾å¼åé¢åŠ åˆ†å·å°±å˜æˆäº†è¯­å¥ã€‚







# Rustä¸­çš„**å‡½æ•°ï¼ˆFunctionsï¼‰**ï¼š

## 1. PARAMETERSï¼ˆå‚æ•°ï¼‰

### åŸºæœ¬å‚æ•°è¯­æ³•

rust

```rust
// å‡½æ•°å®šä¹‰ï¼šå¿…é¡»æ ‡æ³¨å‚æ•°ç±»å‹
fn greet(name: String) {
    println!("ä½ å¥½, {}!", name);
}

// å¤šä¸ªå‚æ•°
fn add(x: i32, y: i32) {
    println!("å’Œæ˜¯: {}", x + y);
}

// ä¸åŒç±»å‹çš„å‚æ•°
fn print_info(name: String, age: u32, active: bool) {
    println!("{} ä»Šå¹´ {} å²ï¼ŒçŠ¶æ€: {}", name, age, active);
}
```

### å‚æ•°ä¼ é€’æ–¹å¼

**1. æŒ‰å€¼ä¼ é€’ï¼ˆé»˜è®¤ï¼‰ï¼š**

rust

```rust
fn consume(s: String) {
    println!("{}", s);
    // s çš„æ‰€æœ‰æƒè¢«è½¬ç§»åˆ°è¿™é‡Œ
}

fn main() {
    let text = String::from("hello");
    consume(text);
    // println!("{}", text);  // âŒ é”™è¯¯ï¼textå·²è¢«ç§»åŠ¨
}
```

**2. å¼•ç”¨ä¼ é€’ï¼ˆå€Ÿç”¨ï¼‰ï¼š**

rust

```rust
// ä¸å¯å˜å¼•ç”¨
fn read(s: &String) {
    println!("{}", s);
    // åªèƒ½è¯»å–ï¼Œä¸èƒ½ä¿®æ”¹
}

// å¯å˜å¼•ç”¨
fn modify(s: &mut String) {
    s.push_str(" world");
}

fn main() {
    let text = String::from("hello");
    read(&text);              // å€Ÿç”¨
    println!("{}", text);     // âœ… textä»ç„¶æœ‰æ•ˆ
    
    let mut text2 = String::from("hello");
    modify(&mut text2);       // å¯å˜å€Ÿç”¨
    println!("{}", text2);    // è¾“å‡º: hello world
}
```

**3. Copyç±»å‹ï¼š**

rust

```rust
// å¯¹äºå®ç°äº†Copy traitçš„ç±»å‹ï¼ˆå¦‚i32ï¼‰ï¼Œä¼šè‡ªåŠ¨å¤åˆ¶
fn square(x: i32) -> i32 {
    x * x
}

fn main() {
    let num = 5;
    let result = square(num);
    println!("num: {}, result: {}", num, result);  // âœ… numä»ç„¶æœ‰æ•ˆ
}
```
## å“ªäº›ç±»å‹å®ç°äº† Copyï¼Ÿ

### è‡ªåŠ¨å®ç° Copy çš„ç±»å‹ï¼š

- æ‰€æœ‰æ•´æ•°ç±»å‹ï¼š`i8`, `i32`, `u64` ç­‰
- æµ®ç‚¹æ•°ï¼š`f32`, `f64`
- å¸ƒå°”å€¼ï¼š`bool`
- å­—ç¬¦ï¼š`char`
- ä¸å¯å˜å¼•ç”¨ï¼š`&T`
- å…ƒç»„ï¼ˆå¦‚æœæ‰€æœ‰å…ƒç´ éƒ½æ˜¯ Copyï¼‰ï¼š`(i32, i32)`
- æ•°ç»„ï¼ˆå¦‚æœå…ƒç´ æ˜¯ Copyï¼‰ï¼š`[i32; 5]`

### ä¸èƒ½å®ç° Copy çš„ç±»å‹ï¼š

- `String`ï¼ˆéœ€è¦ç®¡ç†å †å†…å­˜ï¼‰
- `Vec<T>`ï¼ˆéœ€è¦ç®¡ç†å †å†…å­˜ï¼‰
- `Box<T>`ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰
- ä»»ä½•å®ç°äº† `Drop` trait çš„ç±»å‹

## å®é™…ä¾‹å­å¯¹æ¯”

rust

```rust
// i32 å®ç°äº† Copy
let x = 5;
let y = x;  // è‡ªåŠ¨å¤åˆ¶
println!("{}, {}", x, y); // âœ“ éƒ½å¯ç”¨

// String æ²¡æœ‰å®ç° Copy
let s1 = String::from("hello");
let s2 = s1;  // æ‰€æœ‰æƒè½¬ç§»ï¼ˆmoveï¼‰
// println!("{}", s1); // âœ— é”™è¯¯ï¼s1 å·²å¤±æ•ˆ
println!("{}", s2); // âœ“ åªæœ‰ s2 å¯ç”¨
```





### å‚æ•°æ¨¡å¼åŒ¹é…

rust

```rust
// å…ƒç»„å‚æ•°è§£æ„
fn print_coordinates((x, y): (i32, i32)) {
    println!("åæ ‡: ({}, {})", x, y);
}

// ç»“æ„ä½“å‚æ•°è§£æ„
struct Point {
    x: i32,
    y: i32,
}

fn print_point(Point { x, y }: Point) {
    println!("ç‚¹: ({}, {})", x, y);
}

fn main() {
    print_coordinates((10, 20));
    print_point(Point { x: 5, y: 10 });
}
```

---

## 2. RETURN VALUESï¼ˆè¿”å›å€¼ï¼‰

### åŸºæœ¬è¿”å›è¯­æ³•

rust

```rust
// æ˜¾å¼æ ‡æ³¨è¿”å›ç±»å‹
fn add(x: i32, y: i32) -> i32 {
    x + y  // æ²¡æœ‰åˆ†å·ï¼è¿™æ˜¯è¡¨è¾¾å¼
}

// ä½¿ç”¨returnå…³é”®å­—
fn subtract(x: i32, y: i32) -> i32 {
    return x - y;  // æ˜¾å¼è¿”å›
}

// æ— è¿”å›å€¼ï¼ˆè¿”å›å•å…ƒç±»å‹()ï¼‰
fn print_message(msg: &str) {
    println!("{}", msg);
    // éšå¼è¿”å›()
}

// æ˜¾å¼æ ‡æ³¨()
fn do_nothing() -> () {
    // ä»€ä¹ˆéƒ½ä¸åš
}
```

### è¿”å›å¤æ‚ç±»å‹

rust

```rust
// è¿”å›å…ƒç»„
fn swap(x: i32, y: i32) -> (i32, i32) {
    (y, x)
}

// è¿”å›ç»“æ„ä½“
struct Rectangle {
    width: u32,
    height: u32,
}

fn create_square(size: u32) -> Rectangle {
    Rectangle {
        width: size,
        height: size,
    }
}

// è¿”å›Option
fn divide(x: i32, y: i32) -> Option<i32> {
    if y == 0 {
        None
    } else {
        Some(x / y)
    }
}

// è¿”å›Result
fn parse_number(s: &str) -> Result<i32, String> {
    match s.parse::<i32>() {
        Ok(n) => Ok(n),
        Err(_) => Err(String::from("è§£æå¤±è´¥")),
    }
}
```

### è¿”å›å¼•ç”¨

rust

```rust
// è¿”å›å¼•ç”¨éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn first_element<'a>(list: &'a Vec<i32>) -> &'a i32 {
    &list[0]
}

// è¿”å›å¯å˜å¼•ç”¨
fn first_element_mut<'a>(list: &'a mut Vec<i32>) -> &'a mut i32 {
    &mut list[0]
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let first = first_element(&numbers);
    println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", first);
}
```

---

## 3. EARLY-RETURNï¼ˆæå‰è¿”å›ï¼‰

æå‰è¿”å›ç”¨äºåœ¨æ»¡è¶³ç‰¹å®šæ¡ä»¶æ—¶ç«‹å³é€€å‡ºå‡½æ•°ã€‚

### ä½¿ç”¨returnå…³é”®å­—

rust

```rust
fn check_positive(n: i32) -> String {
    if n < 0 {
        return String::from("è´Ÿæ•°");  // æå‰è¿”å›
    }
    
    if n == 0 {
        return String::from("é›¶");    // æå‰è¿”å›
    }
    
    String::from("æ­£æ•°")  // æ­£å¸¸è¿”å›
}
```

### é”™è¯¯å¤„ç†ä¸­çš„æå‰è¿”å›

rust

```rust
fn process_file(path: &str) -> Result<String, String> {
    // æ£€æŸ¥è·¯å¾„
    if path.is_empty() {
        return Err(String::from("è·¯å¾„ä¸ºç©º"));
    }
    
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if !path.ends_with(".txt") {
        return Err(String::from("ä¸æ˜¯æ–‡æœ¬æ–‡ä»¶"));
    }
    
    // æ­£å¸¸å¤„ç†
    Ok(String::from("å¤„ç†æˆåŠŸ"))
}
```

### ä½¿ç”¨?è¿ç®—ç¬¦ï¼ˆæå‰è¿”å›é”™è¯¯ï¼‰

rust

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;  // å¦‚æœå¤±è´¥ï¼Œæå‰è¿”å›é”™è¯¯
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;  // å¦‚æœå¤±è´¥ï¼Œæå‰è¿”å›é”™è¯¯
    Ok(contents)  // æˆåŠŸè¿”å›
}
```



---

## 4. EXPRESSION-RETURNï¼ˆè¡¨è¾¾å¼è¿”å›ï¼‰

Rustä¸­å‡½æ•°çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼è‡ªåŠ¨ä½œä¸ºè¿”å›å€¼ï¼Œè¿™æ˜¯Rustçš„æ ¸å¿ƒç‰¹æ€§ã€‚

### éšå¼è¿”å›ï¼ˆæ¨èï¼‰

rust

```rust
// âœ… Rusté£æ ¼ï¼šä½¿ç”¨è¡¨è¾¾å¼è¿”å›
fn add(x: i32, y: i32) -> i32 {
    x + y  // æ²¡æœ‰åˆ†å·ï¼Œä½œä¸ºè¿”å›å€¼
}

// âœ… ä½¿ç”¨å—è¡¨è¾¾å¼
fn complex_calculation(x: i32) -> i32 {
    let doubled = x * 2;
    let squared = x * x;
    doubled + squared  // æœ€åçš„è¡¨è¾¾å¼æ˜¯è¿”å›å€¼
}

// âœ… ifè¡¨è¾¾å¼è¿”å›
fn max(x: i32, y: i32) -> i32 {
    if x > y {
        x
    } else {
        y
    }
}

// âœ… matchè¡¨è¾¾å¼è¿”å›
fn describe(n: i32) -> &'static str {
    match n {
        0 => "é›¶",
        1..=10 => "å°æ•°",
        11..=100 => "ä¸­æ•°",
        _ => "å¤§æ•°",
    }
}
```









## 1. BRANCHINGï¼ˆåˆ†æ”¯ï¼‰

### åŸºæœ¬ifè¯­æ³•

rust

```rust
fn main() {
    let number = 7;
    
    // åŸºæœ¬ifè¯­å¥
    if number < 5 {
        println!("æ¡ä»¶ä¸ºçœŸ");
    }
    
    // if-else
    if number < 5 {
        println!("å°äº5");
    } else {
        println!("å¤§äºç­‰äº5");
    }
    
    // if- else if -else
    if number < 5 {
        println!("å°äº5");
    } else if number < 10 {
        println!("5åˆ°9ä¹‹é—´");
    } else {
        println!("å¤§äºç­‰äº10");
    }
}
```

### å¤šé‡åˆ†æ”¯

rust

```rust
fn describe_number(n: i32) {
    if n < 0 {
        println!("è´Ÿæ•°");
    } else if n == 0 {
        println!("é›¶");
    } else if n < 10 {
        println!("ä¸ªä½æ•°");
    } else if n < 100 {
        println!("ä¸¤ä½æ•°");
    } else {
        println!("å¤§æ•°");
    }
}
```

### åµŒå¥—if

rust

```rust
fn check_range(x: i32, y: i32) {
    if x > 0 {
        if y > 0 {
            println!("ä¸¤ä¸ªéƒ½æ˜¯æ­£æ•°");
        } else {
            println!("xæ˜¯æ­£æ•°ï¼Œyä¸æ˜¯");
        }
    } else {
        println!("xä¸æ˜¯æ­£æ•°");
    }
}
```

---

## 2. WHAT IS A VALID CONDITION?ï¼ˆä»€ä¹ˆæ˜¯æœ‰æ•ˆçš„æ¡ä»¶ï¼Ÿï¼‰

### æ¡ä»¶å¿…é¡»æ˜¯å¸ƒå°”ç±»å‹

rust

```rust
fn main() {
    let number = 5;
    
    // âœ… æ­£ç¡®ï¼šæ¡ä»¶æ˜¯boolç±»å‹
    if number > 0 {
        println!("æ­£æ•°");
    }
    
    // âŒ é”™è¯¯ï¼šRustä¸ä¼šè‡ªåŠ¨å°†æ•°å­—è½¬æ¢ä¸ºå¸ƒå°”å€¼
    // if number {  // ç¼–è¯‘é”™è¯¯ï¼
    //     println!("éé›¶");
    // }
    
    // âœ… æ­£ç¡®ï¼šæ˜¾å¼æ¯”è¾ƒ
    if number != 0 {
        println!("éé›¶");
    }
}
```

### æœ‰æ•ˆçš„æ¡ä»¶è¡¨è¾¾å¼


---

## 3. AS AN EXPRESSIONï¼ˆä½œä¸ºè¡¨è¾¾å¼ï¼‰

è¿™æ˜¯Rustçš„é‡è¦ç‰¹æ€§ï¼š**ifæ˜¯è¡¨è¾¾å¼ï¼Œä¸åªæ˜¯è¯­å¥**ï¼

### ifè¡¨è¾¾å¼è¿”å›å€¼

### è¿”å›å€¼çš„è§„åˆ™

rust

```rust
// âœ… æ­£ç¡®ï¼šä¸¤ä¸ªåˆ†æ”¯è¿”å›ç›¸åŒç±»å‹
let x = if true { 5 } else { 6 };

// âŒ é”™è¯¯ï¼šä¸¤ä¸ªåˆ†æ”¯è¿”å›ä¸åŒç±»å‹
// let y = if true { 5 } else { "six" };  // ç¼–è¯‘é”™è¯¯ï¼

// âœ… æ­£ç¡®ï¼šä¸¤ä¸ªåˆ†æ”¯éƒ½è¿”å›&str
let z = if true { "five" } else { "six" };

// âœ… æ­£ç¡®ï¼šä¸¤ä¸ªåˆ†æ”¯éƒ½ä¸è¿”å›å€¼ï¼ˆè¿”å›()ï¼‰
let result = if true {
    println!("æ¡ä»¶ä¸ºçœŸ");
} else {
    println!("æ¡ä»¶ä¸ºå‡");
};
// resultçš„ç±»å‹æ˜¯()
```

### å®é™…åº”ç”¨

rust

```rust
// 1. è®¡ç®—æœ€å¤§å€¼
fn max(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}

// 2. æ ¹æ®æ¡ä»¶é€‰æ‹©æ¶ˆæ¯
fn get_message(score: i32) -> &'static str {
    if score >= 90 {
        "ä¼˜ç§€"
    } else if score >= 70 {
        "è‰¯å¥½"
    } else if score >= 60 {
        "åŠæ ¼"
    } else {
        "ä¸åŠæ ¼"
    }
}

// 3. è®¡ç®—æŠ˜æ‰£
fn calculate_price(original: f64, is_member: bool) -> f64 {
    let discount = if is_member { 0.8 } else { 1.0 };
    original * discount
}

// 4. åœ¨å‡½æ•°ä¸­ç›´æ¥è¿”å›
fn abs(n: i32) -> i32 {
    if n < 0 { -n } else { n }
}
```


---

## 4. TERNARY IF?ï¼ˆä¸‰å…ƒifï¼Ÿï¼‰

Rustæ²¡æœ‰Cé£æ ¼çš„ä¸‰å…ƒè¿ç®—ç¬¦ `condition ? true_val : false_val`ï¼Œä½†ifè¡¨è¾¾å¼å¯ä»¥è¾¾åˆ°ç›¸åŒæ•ˆæœã€‚

### å¯¹æ¯”å…¶ä»–è¯­è¨€

rust

```rust
// C/Java/JavaScriptä¸­çš„ä¸‰å…ƒè¿ç®—ç¬¦:
// int x = condition ? 5 : 6;

// Rustä¸­ä½¿ç”¨ifè¡¨è¾¾å¼:
let x = if condition { 5 } else { 6 };
```


### if let è¯­æ³•ç³–

è™½ç„¶ä¸å®Œå…¨æ˜¯ä¸‰å…ƒè¿ç®—ç¬¦ï¼Œä½† `if let` æä¾›äº†å¦ä¸€ç§ç®€æ´çš„æ¡ä»¶å¤„ç†æ–¹å¼ï¼š

rust

```rust
// å¤„ç†Option
let some_value = Some(5);

// ä¼ ç»Ÿmatch
let x = match some_value {
    Some(val) => val,
    None => 0,
};

// if letè¡¨è¾¾å¼
let y = if let Some(val) = some_value {
    val
} else {
    0
};

// å®é™…ä¾‹å­
fn process(opt: Option<String>) -> String {
    if let Some(s) = opt {
        s
    } else {
        String::from("é»˜è®¤å€¼")
    }
}
```

---







## 1. LOOPï¼ˆæ— é™å¾ªç¯ï¼‰

`loop` åˆ›å»ºä¸€ä¸ªæ— é™å¾ªç¯ï¼Œå¿…é¡»æ˜¾å¼ä½¿ç”¨ `break` é€€å‡ºã€‚

### åŸºæœ¬è¯­æ³•

rust

```rust
fn main() {
    let mut counter = 0;
    
    loop {
        counter += 1;
        println!("è®¡æ•°: {}", counter);
        
        if counter == 5 {
            break;  // é€€å‡ºå¾ªç¯
        }
    }
}
```

### loopçš„ç‰¹ç‚¹

rust

```rust
// 1. æ— é™å¾ªç¯ï¼ˆé™¤ébreakï¼‰
loop {
    println!("æ°¸è¿œæ‰§è¡Œ");
    break;  // å¿…é¡»æœ‰é€€å‡ºæ¡ä»¶
}

// 2. å¸¸ç”¨äºéœ€è¦é‡è¯•çš„åœºæ™¯
fn read_input() -> String {
    loop {
        let input = get_user_input();
        if input.is_valid() {
            break input;  // è¿”å›æœ‰æ•ˆè¾“å…¥
        }
        println!("è¾“å…¥æ— æ•ˆï¼Œè¯·é‡è¯•");
    }
}

// 3. æœåŠ¡å™¨ä¸»å¾ªç¯
fn server_main() {
    loop {
        let connection = accept_connection();
        handle_connection(connection);
    }
}
```

### loopä½œä¸ºè¡¨è¾¾å¼

rust

```rust
fn main() {
    let mut counter = 0;
    
    // loopå¯ä»¥è¿”å›å€¼
    let result = loop {
        counter += 1;
        
        if counter == 10 {
            break counter * 2;  // è¿”å›å€¼
        }
    };
    
    println!("ç»“æœæ˜¯: {}", result);  // è¾“å‡º: 20
}
```

### åµŒå¥—loopå’Œæ ‡ç­¾

rust

```rust
fn main() {
    let mut count = 0;
    
    'outer: loop {  // å¤–å±‚å¾ªç¯æ ‡ç­¾
        println!("å¤–å±‚å¾ªç¯");
        let mut remaining = 10;
        
        'inner: loop {  // å†…å±‚å¾ªç¯æ ‡ç­¾
            println!("  å†…å±‚å¾ªç¯");
            if remaining == 0 {
                break 'outer;  // è·³å‡ºå¤–å±‚å¾ªç¯
            }
            if count == 2 {
                break 'inner;  // è·³å‡ºå†…å±‚å¾ªç¯
            }
            remaining -= 1;
        }
        count += 1;
    }
    
    println!("å¾ªç¯ç»“æŸ");
}
```

---

## 2. WHILEï¼ˆæ¡ä»¶å¾ªç¯ï¼‰

`while` åœ¨æ¡ä»¶ä¸ºçœŸæ—¶é‡å¤æ‰§è¡Œä»£ç å—ã€‚

### åŸºæœ¬è¯­æ³•

rust

```rust
fn main() {
    let mut number = 3;
    
    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }
    
    println!("å‘å°„ï¼");
}
```

### whileçš„åº”ç”¨åœºæ™¯

rust

```rust
// 1. åŸºäºæ¡ä»¶çš„å¾ªç¯
let mut x = 0;
while x < 10 {
    println!("x = {}", x);
    x += 1;
}

// 2. ç­‰å¾…æ¡ä»¶æ»¡è¶³
fn wait_for_ready() {
    while !is_system_ready() {
        std::thread::sleep(std::time::Duration::from_secs(1));
        println!("ç­‰å¾…ç³»ç»Ÿå°±ç»ª...");
    }
}

// 3. å¤„ç†æ ˆæˆ–é˜Ÿåˆ—
let mut stack = vec![1, 2, 3, 4, 5];
while let Some(value) = stack.pop() {
    println!("å¼¹å‡º: {}", value);
}

// 4. è¯»å–ç›´åˆ°EOF
use std::io::{self, BufRead};
fn read_lines() {
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines();
    
    while let Some(Ok(line)) = lines.next() {
        println!("è¯»åˆ°: {}", line);
        if line.is_empty() {
            break;
        }
    }
}
```



---

## 3. FORï¼ˆè¿­ä»£å¾ªç¯ï¼‰

`for` å¾ªç¯éå†è¿­ä»£å™¨ï¼Œæ˜¯Rustä¸­æœ€å¸¸ç”¨çš„å¾ªç¯ã€‚

### åŸºæœ¬è¯­æ³•

rust

```rust
fn main() {
    // éå†æ•°ç»„
    let arr = [10, 20, 30, 40, 50];
    for element in arr {
        println!("å€¼æ˜¯: {}", element);
    }
    
    // éå†èŒƒå›´
    for number in 1..5 {  // 1åˆ°4
        println!("{}", number);
    }
    
    // åŒ…å«ç»“æŸå€¼çš„èŒƒå›´
    for number in 1..=5 {  // 1åˆ°5
        println!("{}", number);
    }
}
```

### forçš„å¤šç§ç”¨æ³•

rust

```rust
// 1. éå†Vector
let v = vec![10, 20, 30];
for item in &v {  // å€Ÿç”¨
    println!("{}", item);
}

// 2. å¯å˜éå†
let mut v = vec![1, 2, 3];
for item in &mut v {
    *item *= 2;
}
println!("{:?}", v);  // [2, 4, 6]

// 3. è·å–ç´¢å¼•
let v = vec!["a", "b", "c"];
for (index, value) in v.iter().enumerate() {
    println!("ç´¢å¼• {}: å€¼ {}", index, value);
}

// 4. éå†å­—ç¬¦ä¸²å­—ç¬¦
let text = "ä½ å¥½ä¸–ç•Œ";
for c in text.chars() {
    println!("{}", c);
}

// 5. éå†HashMap
use std::collections::HashMap;
let mut map = HashMap::new();
map.insert("key1", "value1");
map.insert("key2", "value2");

for (key, value) in &map {
    println!("{}: {}", key, value);
}

// 6. åå‘éå†
for i in (1..5).rev() {
    println!("{}", i);  // 4, 3, 2, 1
}

// 7. æ­¥é•¿éå†
for i in (0..10).step_by(2) {
    println!("{}", i);  // 0, 2, 4, 6, 8
}
```

### for vs while vs loop

rust

```rust
// for - æœ€æ¸…æ™°ï¼ˆæ¨èï¼‰
for i in 0..5 {
    println!("{}", i);
}

// while - éœ€è¦æ‰‹åŠ¨ç®¡ç†è®¡æ•°å™¨
let mut i = 0;
while i < 5 {
    println!("{}", i);
    i += 1;
}

// loop - æœ€ç¹ç
let mut i = 0;
loop {
    if i >= 5 {
        break;
    }
    println!("{}", i);
    i += 1;
}
```

---

## 4. EARLY TERMINATIONï¼ˆæå‰ç»ˆæ­¢ï¼‰

### break - é€€å‡ºå¾ªç¯

rust

```rust
fn main() {
    // ç®€å•break
    for i in 1..10 {
        if i == 5 {
            break;  // é€€å‡ºå¾ªç¯
        }
        println!("{}", i);
    }
    
    // breakå¸¦æ ‡ç­¾
    'outer: for i in 1..5 {
        for j in 1..5 {
            if i * j > 6 {
                break 'outer;  // è·³å‡ºå¤–å±‚å¾ªç¯
            }
            println!("i={}, j={}", i, j);
        }
    }
}
```

### continue - è·³è¿‡å½“å‰è¿­ä»£

rust

```rust
fn main() {
    // è·³è¿‡å¶æ•°
    for i in 1..10 {
        if i % 2 == 0 {
            continue;  // è·³è¿‡æœ¬æ¬¡è¿­ä»£
        }
        println!("{}", i);  // åªæ‰“å°å¥‡æ•°
    }
    
    // è·³è¿‡ç‰¹å®šæ¡ä»¶
    let numbers = vec![1, -2, 3, -4, 5];
    for n in numbers {
        if n < 0 {
            continue;  // è·³è¿‡è´Ÿæ•°
        }
        println!("æ­£æ•°: {}", n);
    }
}
```


### åµŒå¥—å¾ªç¯çš„æå‰ç»ˆæ­¢

rust

```rust
fn main() {
    'outer: for i in 1..5 {
        'inner: for j in 1..5 {
            println!("i={}, j={}", i, j);
            
            if j == 2 {
                continue 'inner;  // è·³è¿‡å†…å±‚å½“å‰è¿­ä»£
            }
            
            if i == 3 {
                break 'outer;     // é€€å‡ºå¤–å±‚å¾ªç¯
            }
        }
    }
}
```

---

## 5. LOOP BREAK VALUEï¼ˆå¾ªç¯breakè¿”å›å€¼ï¼‰

==`loop` å’Œ `break` çš„ä¸€ä¸ªå¼ºå¤§ç‰¹æ€§æ˜¯å¯ä»¥è¿”å›å€¼ã€‚==

### ä»loopè¿”å›å€¼

rust

```rust
fn main() {
    let mut counter = 0;
    
    let result = loop {
        counter += 1;
        
        if counter == 10 {
            break counter * 2;  // è¿”å›20
        }
    };
    
    println!("ç»“æœ: {}", result);
}
```









å¥½çš„ï¼Œè®©æˆ‘ä¸ºæ‚¨è¯¦ç»†è®²è§£Rustä¸­çš„**æ‰€æœ‰æƒï¼ˆOwnershipï¼‰**ç³»ç»Ÿï¼Œè¿™æ˜¯Rustæœ€æ ¸å¿ƒã€æœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼

## ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒï¼Ÿ

æ‰€æœ‰æƒæ˜¯Rustç”¨æ¥ç®¡ç†å†…å­˜çš„ç³»ç»Ÿï¼Œå®ƒè®©Rustæ— éœ€åƒåœ¾å›æ”¶å™¨ï¼ˆGCï¼‰å°±èƒ½ä¿è¯å†…å­˜å®‰å…¨ã€‚

### æ‰€æœ‰æƒä¸‰å¤§è§„åˆ™

1. **æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼ˆownerï¼‰**
2. **ä¸€ä¸ªå€¼åœ¨åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…**
3. **å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒï¼ˆdroppedï¼‰**

---

## 1. ONE OWNERï¼ˆå•ä¸€æ‰€æœ‰è€…ï¼‰

### åŸºæœ¬æ¦‚å¿µ

rust

```rust
fn main() {
    // s æ˜¯ String çš„æ‰€æœ‰è€…
    let s = String::from("hello");
    
    // è¿™é‡Œ s æ‹¥æœ‰è¿™ä¸ª String
    println!("{}", s);
    
}  // s ç¦»å¼€ä½œç”¨åŸŸï¼ŒString è¢«è‡ªåŠ¨é‡Šæ”¾ï¼ˆdropï¼‰
```

### å˜é‡ä½œç”¨åŸŸ

rust

```rust
fn main() {
    {
        let s = String::from("hello");  // s æœ‰æ•ˆ
        // å¯ä»¥ä½¿ç”¨ s
    }  // s ç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«drop
    
    // println!("{}", s);  // âŒ é”™è¯¯ï¼s å·²ç»ä¸å­˜åœ¨
}
```

### æ‰€æœ‰æƒä¸ç±»å‹

rust

```rust
// æ ˆä¸Šçš„æ•°æ®ï¼ˆå®ç°äº†Copy traitï¼‰
let x = 5;
let y = x;  // å¤åˆ¶
println!("x = {}, y = {}", x, y);  // âœ… x ä»ç„¶æœ‰æ•ˆ
//æ ˆä¸Šçš„æ•°æ®ï¼Œå› ä¸ºå¤åˆ¶æˆæœ¬ä½ï¼Œæ‰€ä»¥è‡ªåŠ¨éšå¼å¤åˆ¶

// å †ä¸Šçš„æ•°æ®ï¼ˆString, Vecç­‰ï¼‰
let s1 = String::from("hello");
let s2 = s1;  // æ‰€æœ‰æƒè½¬ç§»ï¼ˆmoveï¼‰
// println!("{}", s1);  // âŒ é”™è¯¯ï¼s1 å·²ç»æ— æ•ˆ
println!("{}", s2);  // âœ… s2 æ˜¯æ‰€æœ‰è€…
//å †æ•°æ®å¤åˆ¶æˆæœ¬é«˜ï¼šå¦‚æœè¦å¤åˆ¶ï¼Œå¿…é¡»æ˜¾å¼è°ƒç”¨
```
## ä¸ºä»€ä¹ˆæ ˆä¸Šæ•°æ®å¯ä»¥å¤åˆ¶ï¼Ÿ

æ ˆä¸Šçš„æ•°æ®ï¼ˆå®ç°äº† Copy traitï¼‰**å¤§å°å›ºå®šä¸”å·²çŸ¥**ï¼Œå¤åˆ¶æˆæœ¬ä½ï¼š

## ä¸ºä»€ä¹ˆå †ä¸Šæ•°æ®ä¸èƒ½å¤åˆ¶ï¼Ÿ

å †ä¸Šçš„æ•°æ®å¤§å°ä¸å›ºå®šï¼Œå¤åˆ¶æˆæœ¬å¯èƒ½å¾ˆé«˜ï¼š


---

## 2. TRANSFER OF OWNERSHIP (MOVE)ï¼ˆæ‰€æœ‰æƒè½¬ç§»ï¼‰

### èµ‹å€¼æ—¶çš„ç§»åŠ¨

rust

````rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 çš„æ‰€æœ‰æƒè½¬ç§»ç»™ s2
    
    // println!("{}", s1);  // âŒ é”™è¯¯ï¼s1 å·²ç»è¢«ç§»åŠ¨
    println!("{}", s2);     // âœ… æ­£ç¡®
}
```

**å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ**
```
ä¹‹å‰:
s1 -> [ptr, len, capacity] -> å †ä¸Šçš„ "hello"

ä¹‹å:
s1 -> âŒ æ— æ•ˆ
s2 -> [ptr, len, capacity] -> å †ä¸Šçš„ "hello"
````

### å‡½æ•°å‚æ•°ä¸­çš„ç§»åŠ¨

rust

```rust
fn main() {
    let s = String::from("hello");
    
    take_ownership(s);  // s çš„æ‰€æœ‰æƒè½¬ç§»ç»™å‡½æ•°
    
    // println!("{}", s);  // âŒ é”™è¯¯ï¼s å·²ç»è¢«ç§»åŠ¨
}

fn take_ownership(some_string: String) {
    println!("{}", some_string);
}  // some_string ç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«drop
```

### å‡½æ•°è¿”å›å€¼ä¸­çš„ç§»åŠ¨

rust

```rust
fn main() {
    let s1 = gives_ownership();  // å‡½æ•°è¿”å›å€¼çš„æ‰€æœ‰æƒè½¬ç§»ç»™ s1
    println!("{}", s1);
    
    let s2 = String::from("hello");
    let s3 = takes_and_gives_back(s2);  // s2 è¢«ç§»åŠ¨ï¼Œè¿”å›å€¼çš„æ‰€æœ‰æƒç»™ s3
    
    // println!("{}", s2);  // âŒ é”™è¯¯ï¼s2 å·²è¢«ç§»åŠ¨
    println!("{}", s3);     // âœ… æ­£ç¡®
}

fn gives_ownership() -> String {
    let some_string = String::from("yours");
    some_string  // è¿”å›å¹¶ç§»åŠ¨æ‰€æœ‰æƒ
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string  // è¿”å›å¹¶ç§»åŠ¨æ‰€æœ‰æƒ
}
```

### Copy vs Move

rust

```rust
// å®ç°äº† Copy trait çš„ç±»å‹ï¼ˆæ ˆä¸Šæ•°æ®ï¼‰
let x = 5;
let y = x;  // å¤åˆ¶ï¼Œx ä»ç„¶æœ‰æ•ˆ
println!("x = {}, y = {}", x, y);

// å¸¸è§çš„ Copy ç±»å‹ï¼š
// - æ‰€æœ‰æ•´æ•°ç±»å‹ï¼ši32, u32, i64...
// - æµ®ç‚¹ç±»å‹ï¼šf32, f64
// - å¸ƒå°”ç±»å‹ï¼šbool
// - å­—ç¬¦ç±»å‹ï¼šchar
// - å…ƒç»„ï¼ˆå¦‚æœæ‰€æœ‰å…ƒç´ éƒ½æ˜¯Copyï¼‰ï¼š(i32, i32)

// æ²¡æœ‰å®ç° Copy trait çš„ç±»å‹ï¼ˆå †ä¸Šæ•°æ®ï¼‰
let s1 = String::from("hello");
let s2 = s1;  // ç§»åŠ¨ï¼Œs1 ä¸å†æœ‰æ•ˆ
// println!("{}", s1);  // âŒ é”™è¯¯

// å¸¸è§çš„é Copy ç±»å‹ï¼š
// - String
// - Vec<T>
// - Box<T>
// - è‡ªå®šä¹‰çš„å¤æ‚ç»“æ„ä½“
```

---

## 3. DROP (VS GC? RC?)ï¼ˆDrop vs åƒåœ¾å›æ”¶ï¼Ÿå¼•ç”¨è®¡æ•°ï¼Ÿï¼‰

### Drop trait

Rustä½¿ç”¨**RAII**ï¼ˆResource Acquisition Is Initializationï¼‰æ¨¡å¼ç®¡ç†èµ„æºã€‚

rust

```rust
fn main() {
    {
        let s = String::from("hello");
        // ä½¿ç”¨ s
    }  // s ç¦»å¼€ä½œç”¨åŸŸï¼Œè‡ªåŠ¨è°ƒç”¨ drop
}

// Drop çš„å®ç°ç¤ºä¾‹ï¼ˆç®€åŒ–ç‰ˆï¼‰
impl Drop for String {
    fn drop(&mut self) {
        // é‡Šæ”¾å †ä¸Šçš„å†…å­˜
        // è¿™æ˜¯è‡ªåŠ¨å‘ç”Ÿçš„ï¼
    }
}
```

### è‡ªå®šä¹‰ Drop

rust

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("é‡Šæ”¾èµ„æº: {}", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("æˆ‘çš„æ•°æ®"),
    };
    println!("åˆ›å»ºäº† CustomSmartPointer");
}  // c ç¦»å¼€ä½œç”¨åŸŸï¼Œè‡ªåŠ¨è°ƒç”¨ drop
   // è¾“å‡º: é‡Šæ”¾èµ„æº: æˆ‘çš„æ•°æ®
```

### Drop vs GC vs RC

**1. Rustçš„Dropï¼ˆæ‰€æœ‰æƒç³»ç»Ÿï¼‰**

rust

````rust
// âœ… ç¼–è¯‘æ—¶ç¡®å®šä½•æ—¶é‡Šæ”¾å†…å­˜
{
    let s = String::from("hello");
}  // ç¡®å®šæ€§é‡Šæ”¾ï¼Œæ— è¿è¡Œæ—¶å¼€é”€
```

**2. åƒåœ¾å›æ”¶ï¼ˆGCï¼‰- å¦‚Java, Go**
```
// è¿è¡Œæ—¶ä¸ç¡®å®šä½•æ—¶é‡Šæ”¾
String s = new String("hello");
// ... ä½¿ç”¨ s
// GC ä¼šåœ¨æŸä¸ªæ—¶é—´ç‚¹å›æ”¶ï¼Œä¸ç¡®å®š
````

**3. å¼•ç”¨è®¡æ•°ï¼ˆRCï¼‰- å¦‚Python, Swift**

rust

```rust
use std::rc::Rc;

// Rust ä¹Ÿæä¾› Rcï¼ˆå¼•ç”¨è®¡æ•°ï¼‰ä½œä¸ºé€‰é¡¹
let a = Rc::new(String::from("hello"));
let b = Rc::clone(&a);  // å¼•ç”¨è®¡æ•° +1
// å½“å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶é‡Šæ”¾
```

### å¯¹æ¯”è¡¨

|æ–¹å¼|é‡Šæ”¾æ—¶æœº|æ€§èƒ½å¼€é”€|å†…å­˜å®‰å…¨|Rustä½¿ç”¨|
|---|---|---|---|---|
|**Ownership/Drop**|ç¼–è¯‘æ—¶ç¡®å®š|æ— |âœ…|é»˜è®¤|
|**GC**|è¿è¡Œæ—¶ä¸ç¡®å®š|æœ‰|âœ…|âŒ ä¸ç”¨|
|**RC**|å¼•ç”¨è®¡æ•°ä¸º0æ—¶|å°|âœ…|å¯é€‰ï¼ˆRc, Arcï¼‰|
|**æ‰‹åŠ¨ç®¡ç†**|ç¨‹åºå‘˜æ§åˆ¶|æ— |âŒ|âŒ ä¸éœ€è¦|

---

## 4. ESCAPE HATCH: CLONEï¼ˆé€ƒç”Ÿèˆ±ï¼šå…‹éš†ï¼‰

æœ‰æ—¶æˆ‘ä»¬ç¡®å®éœ€è¦æ·±æ‹·è´æ•°æ®ï¼Œè¿™æ—¶å¯ä»¥ä½¿ç”¨ `clone()`ã€‚

### ä½¿ç”¨ Clone

rust

````rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // æ·±æ‹·è´ï¼Œs1 ä»ç„¶æœ‰æ•ˆ
    
    println!("s1 = {}, s2 = {}", s1, s2);  // âœ… ä¸¤ä¸ªéƒ½æœ‰æ•ˆ
}
```

**å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ**
```
s1 -> [ptr, len, capacity] -> å †ä¸Šçš„ "hello"
s2 -> [ptr, len, capacity] -> å †ä¸Šçš„ "hello" (æ–°çš„å‰¯æœ¬)
````

### Clone vs Copy

rust

```rust
// Copyï¼šéšå¼çš„ã€å»‰ä»·çš„ï¼ˆæ ˆä¸Šæ•°æ®ï¼‰
let x = 5;
let y = x;  // è‡ªåŠ¨å¤åˆ¶

// Cloneï¼šæ˜¾å¼çš„ã€å¯èƒ½æ˜‚è´µçš„ï¼ˆå †ä¸Šæ•°æ®ï¼‰
let s1 = String::from("hello");
let s2 = s1.clone();  // éœ€è¦æ˜¾å¼è°ƒç”¨

// Clone ç”¨äºå¤æ‚ç±»å‹
let v1 = vec![1, 2, 3];
let v2 = v1.clone();  // æ·±æ‹·è´æ•´ä¸ª Vec
```

### ä½•æ—¶ä½¿ç”¨ Cloneï¼Ÿ

rust

```rust
// 1. éœ€è¦ä¿ç•™åŸå§‹æ•°æ®æ—¶
let original = String::from("important data");
let backup = original.clone();
process(original);  // å³ä½¿ original è¢«ç§»åŠ¨
restore_from(backup);  // backup ä»ç„¶æœ‰æ•ˆ

// 2. åœ¨é›†åˆä¸­å­˜å‚¨å¤šä¸ªå‰¯æœ¬
let name = String::from("Alice");
let mut list = Vec::new();
list.push(name.clone());
list.push(name.clone());
// name ä»ç„¶æœ‰æ•ˆ

// 3. ä¼ é€’ç»™å‡½æ•°ä½†ä¿ç•™æ‰€æœ‰æƒ
fn print_and_keep(s: String) {
    let data = String::from("data");
    print_value(data.clone());  // ä¼ é€’å‰¯æœ¬
    // data ä»ç„¶æœ‰æ•ˆï¼Œå¯ä»¥ç»§ç»­ä½¿ç”¨
}

// 4. é¿å…å€Ÿç”¨æ£€æŸ¥å™¨çš„é™åˆ¶ï¼ˆæœ‰æ—¶ï¼‰
struct Container {
    data: String,
}

fn example() {
    let c = Container {
        data: String::from("hello"),
    };
    let copy = c.data.clone();  // åˆ›å»ºç‹¬ç«‹å‰¯æœ¬
}
```

### Clone çš„æ€§èƒ½è€ƒè™‘

rust

```rust
// âš ï¸ Clone å¯èƒ½å¾ˆæ˜‚è´µ
let large_vec = vec![0; 1_000_000];
let copy = large_vec.clone();  // å¤åˆ¶100ä¸‡ä¸ªå…ƒç´ ï¼

// âœ… æ›´å¥½çš„åšæ³•ï¼šä½¿ç”¨å¼•ç”¨
fn process_data(data: &Vec<i32>) {
    // åªè¯»å–ï¼Œä¸éœ€è¦æ‰€æœ‰æƒ
}

let large_vec = vec![0; 1_000_000];
process_data(&large_vec);  // ä¸å¤åˆ¶ï¼Œåªæ˜¯å€Ÿç”¨
```

---










## Copy trait æ¦‚è¿°

Copy trait æ˜¯ Rust ä¸­çš„ä¸€ä¸ªç‰¹æ®Š traitï¼Œå®ƒæ ‡è®°äº†é‚£äº›å¯ä»¥ç®€å•åœ°é€šè¿‡**æŒ‰ä½å¤åˆ¶**æ¥å¤åˆ¶çš„ç±»å‹ã€‚è¿™äº›ç±»å‹åœ¨èµ‹å€¼æˆ–ä¼ é€’æ—¶ä¼š**è‡ªåŠ¨å¤åˆ¶**ï¼Œè€Œä¸æ˜¯è½¬ç§»æ‰€æœ‰æƒã€‚

---

## 1. DOES NOT FOLLOW OWNERSHIPï¼ˆä¸éµå¾ªæ‰€æœ‰æƒè§„åˆ™ï¼‰

å®ç°äº† Copy çš„ç±»å‹æœ‰ç‰¹æ®Šè¡Œä¸ºï¼šå®ƒä»¬åœ¨èµ‹å€¼æ—¶ä¼š**å¤åˆ¶**è€Œä¸æ˜¯**ç§»åŠ¨**ã€‚

### å¯¹æ¯”ï¼šCopy vs Move

rust

```rust
// é Copy ç±»å‹ï¼ˆStringï¼‰ï¼šç§»åŠ¨æ‰€æœ‰æƒ
let s1 = String::from("hello");
let s2 = s1;  // s1 è¢«ç§»åŠ¨åˆ° s2
// println!("{}", s1);  // âŒ é”™è¯¯ï¼s1 å·²æ— æ•ˆ

// Copy ç±»å‹ï¼ˆi32ï¼‰ï¼šå¤åˆ¶å€¼
let x = 5;
let y = x;  // x è¢«å¤åˆ¶åˆ° y
println!("x = {}, y = {}", x, y);  // âœ… x å’Œ y éƒ½æœ‰æ•ˆ
```

### ä¸ºä»€ä¹ˆ Copy ç±»å‹ä¸éµå¾ªæ‰€æœ‰æƒè§„åˆ™ï¼Ÿ



**åŸå› ï¼š** Copy ç±»å‹çš„æ•°æ®å­˜å‚¨åœ¨**æ ˆä¸Š**ï¼Œå¤åˆ¶æˆæœ¬éå¸¸ä½ï¼ˆåªæ˜¯ç®€å•çš„ä½å¤åˆ¶ï¼‰ï¼Œæ‰€ä»¥ Rust å…è®¸éšå¼å¤åˆ¶ã€‚

---

## 2. VALUE SEMANTICSï¼ˆå€¼è¯­ä¹‰ï¼‰

Copy ç±»å‹å…·æœ‰**å€¼è¯­ä¹‰**ï¼šæ¯æ¬¡èµ‹å€¼éƒ½åˆ›å»ºä¸€ä¸ªæ–°çš„ç‹¬ç«‹å‰¯æœ¬ã€‚

rust

```rust
fn main() {
    let x = 5;
    let y = x;  // y æ˜¯ x çš„å‰¯æœ¬
    
    // x å’Œ y æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„å€¼
    let z = y;
    
    // ä¿®æ”¹ä¸€ä¸ªä¸å½±å“å¦ä¸€ä¸ª
    println!("x = {}", x);  // 5
    println!("y = {}", y);  // 5
    println!("z = {}", z);  // 5
}
```

### å€¼è¯­ä¹‰ vs å¼•ç”¨è¯­ä¹‰

rust

```rust
// å€¼è¯­ä¹‰ï¼ˆCopyï¼‰
let a = 10;
let b = a;  // b æ˜¯ a çš„ç‹¬ç«‹å‰¯æœ¬
// ä¿®æ”¹ a ä¸ä¼šå½±å“ b

// å¼•ç”¨è¯­ä¹‰ï¼ˆé Copyï¼‰
let s1 = String::from("hello");
let s2 = s1;  // s2 æ¥ç®¡ s1 çš„æ‰€æœ‰æƒ
// s1 ä¸å†æœ‰æ•ˆï¼Œåªæœ‰ä¸€ä¸ª String å¯¹è±¡
```


---

## 3. SIMPLE SCALAR TYPESï¼ˆç®€å•æ ‡é‡ç±»å‹ï¼‰

æ‰€æœ‰ç®€å•çš„æ ‡é‡ç±»å‹éƒ½å®ç°äº† Copyã€‚

### å†…ç½®çš„ Copy ç±»å‹

rust

```rust
// 1. æ‰€æœ‰æ•´æ•°ç±»å‹
let a: i8 = 1;
let b: i16 = 1;
let c: i32 = 1;
let d: i64 = 1;
let e: i128 = 1;
let f: isize = 1;

let g: u8 = 1;
let h: u16 = 1;
let i: u32 = 1;
let j: u64 = 1;
let k: u128 = 1;
let l: usize = 1;

// 2. æµ®ç‚¹ç±»å‹
let m: f32 = 1.0;
let n: f64 = 1.0;

// 3. å¸ƒå°”ç±»å‹
let o: bool = true;

// 4. å­—ç¬¦ç±»å‹
let p: char = 'a';

// æ‰€æœ‰è¿™äº›ç±»å‹åœ¨èµ‹å€¼æ—¶éƒ½ä¼šå¤åˆ¶
let x = a;  // a è¢«å¤åˆ¶ï¼Œa ä»ç„¶æœ‰æ•ˆ
```

### ä¸ºä»€ä¹ˆè¿™äº›ç±»å‹æ˜¯ Copyï¼Ÿ

rust

```rust
// è¿™äº›ç±»å‹çš„ç‰¹ç‚¹ï¼š
// 1. å›ºå®šå¤§å°
// 2. å­˜å‚¨åœ¨æ ˆä¸Š
// 3. å¤åˆ¶æˆæœ¬ä½ï¼ˆåªæ˜¯æŒ‰ä½å¤åˆ¶ï¼‰

let x: i32 = 42;  // 4 å­—èŠ‚
let y = x;        // å¤åˆ¶ 4 å­—èŠ‚ï¼Œéå¸¸å¿«

// å¯¹æ¯”ï¼šé Copy ç±»å‹
let s: String = String::from("hello");  // å †ä¸Šåˆ†é…
// å¤åˆ¶ String éœ€è¦åˆ†é…æ–°å†…å­˜ï¼Œæˆæœ¬é«˜
```

---

## 4. TUPLES? ARRAYS?ï¼ˆå…ƒç»„ï¼Ÿæ•°ç»„ï¼Ÿï¼‰

å…ƒç»„å’Œæ•°ç»„**å¯ä»¥**æ˜¯ Copyï¼Œä½†æœ‰æ¡ä»¶ã€‚

### å…ƒç»„çš„ Copy è§„åˆ™

rust

```rust
// âœ… å…ƒç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½æ˜¯ Copy â†’ å…ƒç»„æ˜¯ Copy
let t1: (i32, i32) = (1, 2);
let t2 = t1;  // å¤åˆ¶
println!("t1: {:?}, t2: {:?}", t1, t2);  // éƒ½æœ‰æ•ˆ

let t3: (i32, bool, char) = (1, true, 'a');
let t4 = t3;  // å¤åˆ¶
println!("t3: {:?}", t3);  // âœ… t3 ä»æœ‰æ•ˆ

// âŒ å…ƒç»„ä¸­æœ‰é Copy å…ƒç´  â†’ å…ƒç»„ä¸æ˜¯ Copy
let t5: (i32, String) = (1, String::from("hello"));
let t6 = t5;  // ç§»åŠ¨ï¼Œä¸æ˜¯å¤åˆ¶
// println!("{:?}", t5);  // âŒ é”™è¯¯ï¼t5 å·²è¢«ç§»åŠ¨
```

### æ•°ç»„çš„ Copy è§„åˆ™

rust

```rust
// âœ… æ•°ç»„å…ƒç´ æ˜¯ Copy â†’ æ•°ç»„æ˜¯ Copy
let arr1: [i32; 3] = [1, 2, 3];
let arr2 = arr1;  // å¤åˆ¶æ•´ä¸ªæ•°ç»„
println!("arr1: {:?}, arr2: {:?}", arr1, arr2);  // éƒ½æœ‰æ•ˆ

let arr3: [bool; 5] = [true; 5];
let arr4 = arr3;  // å¤åˆ¶
println!("arr3: {:?}", arr3);  // âœ… ä»æœ‰æ•ˆ

// âŒ æ•°ç»„å…ƒç´ ä¸æ˜¯ Copy â†’ æ•°ç»„ä¸æ˜¯ Copy
let arr5: [String; 2] = [
    String::from("hello"),
    String::from("world"),
];
let arr6 = arr5;  // ç§»åŠ¨
// println!("{:?}", arr5);  // âŒ é”™è¯¯ï¼
```

### å¤§å°é™åˆ¶

rust

```rust
// å³ä½¿å…ƒç´ æ˜¯ Copyï¼Œå¤§æ•°ç»„ä¹Ÿè¦å°å¿ƒ
let large: [i32; 1000] = [0; 1000];
let copy = large;  // å¤åˆ¶ 4000 å­—èŠ‚ï¼

// è€ƒè™‘ä½¿ç”¨å¼•ç”¨
fn process(arr: &[i32; 1000]) {
    // ä½¿ç”¨å¼•ç”¨ï¼Œä¸å¤åˆ¶
}
```

---

## 5. STRUCTS? ENUMS?ï¼ˆç»“æ„ä½“ï¼Ÿæšä¸¾ï¼Ÿï¼‰

è‡ªå®šä¹‰ç±»å‹ï¼ˆç»“æ„ä½“å’Œæšä¸¾ï¼‰å¯ä»¥å®ç° Copyï¼Œä½†éœ€è¦æ»¡è¶³æ¡ä»¶ã€‚

### ç»“æ„ä½“çš„ Copy

rust

```rust
// âœ… æ‰€æœ‰å­—æ®µéƒ½æ˜¯ Copy â†’ å¯ä»¥æ´¾ç”Ÿ Copy
#[derive(Copy, Clone)]  // éœ€è¦åŒæ—¶æ´¾ç”Ÿ Clone
struct Point {
    x: i32,
    y: i32,
}

let p1 = Point { x: 0, y: 0 };
let p2 = p1;  // å¤åˆ¶
println!("p1: ({}, {})", p1.x, p1.y);  // âœ… p1 ä»æœ‰æ•ˆ

// âœ… åŒ…å«å…¶ä»– Copy ç±»å‹
#[derive(Copy, Clone)]
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

// âŒ åŒ…å«é Copy å­—æ®µ â†’ ä¸èƒ½æ˜¯ Copy
struct Person {
    name: String,  // String ä¸æ˜¯ Copy
    age: i32,
}

// let p1 = Person {
//     name: String::from("Alice"),
//     age: 30,
// };
// let p2 = p1;  // ç§»åŠ¨ï¼Œä¸æ˜¯å¤åˆ¶
```

### æšä¸¾çš„ Copy

rust

```rust
// âœ… æ‰€æœ‰å˜ä½“éƒ½æ˜¯ Copy â†’ æšä¸¾æ˜¯ Copy
#[derive(Copy, Clone)]
enum Direction {
    North,
    South,
    East,
    West,
}

let d1 = Direction::North;
let d2 = d1;  // å¤åˆ¶
match d1 {  // âœ… d1 ä»æœ‰æ•ˆ
    Direction::North => println!("åŒ—"),
    _ => println!("å…¶ä»–"),
}

// âœ… å˜ä½“åŒ…å« Copy ç±»å‹
#[derive(Copy, Clone)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Color(u8, u8, u8),
}

// âŒ å˜ä½“åŒ…å«é Copy ç±»å‹
enum Command {
    Print(String),  // String ä¸æ˜¯ Copy
    Quit,
}
```

### Copy çš„è¦æ±‚

è¦å®ç° Copyï¼Œç±»å‹å¿…é¡»æ»¡è¶³ï¼š

rust

```rust
// 1. æ‰€æœ‰å­—æ®µ/å˜ä½“éƒ½å¿…é¡»æ˜¯ Copy
#[derive(Copy, Clone)]
struct Valid {
    a: i32,      // âœ… Copy
    b: bool,     // âœ… Copy
    c: char,     // âœ… Copy
}

// 2. å¿…é¡»åŒæ—¶å®ç° Clone
#[derive(Copy, Clone)]  // Copy éœ€è¦ Clone
struct Point {
    x: i32,
    y: i32,
}

// 3. ä¸èƒ½åŒ…å«é Copy ç±»å‹
// struct Invalid {
//     data: String,  // âŒ String ä¸æ˜¯ Copy
// }

// 4. ä¸èƒ½æœ‰ Drop å®ç°
// å¦‚æœç±»å‹éœ€è¦è‡ªå®šä¹‰æ¸…ç†ï¼Œå®ƒä¸åº”è¯¥æ˜¯ Copy
```









## æ‰€æœ‰æƒä¸å‡½æ•°

æ‰€æœ‰æƒè§„åˆ™åœ¨å‡½æ•°è°ƒç”¨æ—¶åŒæ ·é€‚ç”¨ã€‚å‡½æ•°å‚æ•°çš„ä¼ é€’å’Œè¿”å›å€¼éƒ½ä¼šæ¶‰åŠæ‰€æœ‰æƒçš„è½¬ç§»æˆ–å€Ÿç”¨ã€‚

---

## 1. PASSING OWNERSHIP INTO A FNï¼ˆå°†æ‰€æœ‰æƒä¼ é€’ç»™å‡½æ•°ï¼‰

å½“å°†å€¼ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œæ‰€æœ‰æƒä¼šè½¬ç§»åˆ°å‡½æ•°å‚æ•°ä¸­ã€‚

### åŸºæœ¬ç¤ºä¾‹

rust

````rust
fn main() {
    let s = String::from("hello");
    
    take_ownership(s);  // s çš„æ‰€æœ‰æƒè½¬ç§»ç»™å‡½æ•°
    
    // println!("{}", s);  // âŒ é”™è¯¯ï¼s å·²ç»è¢«ç§»åŠ¨
}

fn take_ownership(some_string: String) {
    println!("{}", some_string);
}  // some_string åœ¨è¿™é‡Œç¦»å¼€ä½œç”¨åŸŸå¹¶è¢« drop
```

**å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ**
```
è°ƒç”¨å‰:
main::s -> String("hello")

è°ƒç”¨æ—¶:
take_ownership::some_string -> String("hello")  // æ‰€æœ‰æƒè½¬ç§»
main::s -> âŒ æ— æ•ˆ

å‡½æ•°ç»“æŸ:
String("hello") è¢« drop
````

### Copy ç±»å‹ä¸è½¬ç§»æ‰€æœ‰æƒ

rust

```rust
fn main() {
    let x = 5;
    
    makes_copy(x);  // x è¢«å¤åˆ¶ï¼Œä¸æ˜¯ç§»åŠ¨
    
    println!("x ä»ç„¶æ˜¯: {}", x);  // âœ… x ä»ç„¶æœ‰æ•ˆ
}

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}  // some_integer ç¦»å¼€ä½œç”¨åŸŸï¼Œä½†æ²¡æœ‰ç‰¹æ®Šæ“ä½œï¼ˆå› ä¸ºæ˜¯ Copyï¼‰
```



---

## 2. OWNERSHIP OUT OF A FNï¼ˆä»å‡½æ•°è¿”å›æ‰€æœ‰æƒï¼‰

å‡½æ•°å¯ä»¥é€šè¿‡è¿”å›å€¼å°†æ‰€æœ‰æƒè½¬ç§»ç»™è°ƒç”¨è€…ã€‚

### åŸºæœ¬è¿”å›

rust

```rust
fn main() {
    let s = gives_ownership();  // å‡½æ•°è¿”å›çš„æ‰€æœ‰æƒè½¬ç§»ç»™ s
    println!("{}", s);
}

fn gives_ownership() -> String {
    let some_string = String::from("yours");
    some_string  // è¿”å›å€¼ï¼Œæ‰€æœ‰æƒè½¬ç§»å‡ºå»
}  // some_string çš„æ‰€æœ‰æƒè¢«è½¬ç§»ï¼Œä¸ä¼š drop
```

### æ¥æ”¶å¹¶è¿”å›æ‰€æœ‰æƒ

rust

```rust
fn main() {
    let s1 = String::from("hello");
    
    let s2 = takes_and_gives_back(s1);  // s1 è¢«ç§»å…¥ï¼Œè¿”å›å€¼ç»™ s2
    
    // println!("{}", s1);  // âŒ s1 å·²è¢«ç§»åŠ¨
    println!("{}", s2);     // âœ… s2 æ‹¥æœ‰æ‰€æœ‰æƒ
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string  // è¿”å›ï¼Œè½¬ç§»æ‰€æœ‰æƒ
}
```



---

## æ‰€æœ‰æƒä¼ é€’çš„å®Œæ•´æµç¨‹

rust

```rust
fn main() {
    // 1. åˆ›å»ºæ‰€æœ‰æƒ
    let s1 = String::from("hello");
    println!("s1: {}", s1);
    
    // 2. ä¼ å…¥å‡½æ•°ï¼ˆè½¬ç§»æ‰€æœ‰æƒï¼‰
    let s2 = takes_and_gives(s1);
    // s1 ç°åœ¨æ— æ•ˆ
    
    // 3. ä½¿ç”¨è¿”å›çš„æ‰€æœ‰æƒ
    println!("s2: {}", s2);
    
    // 4. å†æ¬¡ä¼ é€’
    do_something(s2);
    // s2 ç°åœ¨æ— æ•ˆ
}

fn takes_and_gives(s: String) -> String {
    println!("å‡½æ•°å†…: {}", s);
    s  // è¿”å›æ‰€æœ‰æƒ
}

fn do_something(s: String) {
    println!("æœ€åå¤„ç†: {}", s);
}  // s åœ¨è¿™é‡Œè¢« drop
```

---

## é¿å…ä¸å¿…è¦çš„æ‰€æœ‰æƒè½¬ç§»ï¼šä½¿ç”¨å¼•ç”¨

è™½ç„¶ç†è§£æ‰€æœ‰æƒä¼ é€’å¾ˆé‡è¦ï¼Œä½†åœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨**å¼•ç”¨**æ¥é¿å…ä¸å¿…è¦çš„æ‰€æœ‰æƒè½¬ç§»ã€‚

### é—®é¢˜ï¼šç¹ççš„æ‰€æœ‰æƒä¼ é€’

rust

```rust
// âŒ ç¹çï¼šéœ€è¦è¿”å›æ‰€æœ‰æƒ
fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)  // å¿…é¡»è¿”å› String æ‰èƒ½ç»§ç»­ä½¿ç”¨
}

fn main() {
    let s1 = String::from("hello");
    let (s2, len) = calculate_length(s1);
    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s2, len);
}
```

### è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨å¼•ç”¨ï¼ˆä¸‹ä¸€ä¸ªä¸»é¢˜ï¼‰

rust

```rust
// âœ… ç®€æ´ï¼šä½¿ç”¨å¼•ç”¨
fn calculate_length(s: &String) -> usize {
    s.len()  // åªè¿”å›é•¿åº¦ï¼Œä¸éœ€è¦è¿”å› String
}

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);  // å€Ÿç”¨ï¼Œä¸è½¬ç§»æ‰€æœ‰æƒ
    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len);  // s1 ä»ç„¶æœ‰æ•ˆ
}
```





## Match è¡¨è¾¾å¼

`match` æ˜¯ Rust ä¸­å¼ºå¤§çš„æ§åˆ¶æµè¿ç®—ç¬¦ï¼Œå®ƒå…è®¸ä½ å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„ä»£ç ã€‚

---

## 1. PATTERN MATCHINGï¼ˆæ¨¡å¼åŒ¹é…ï¼‰

### åŸºæœ¬è¯­æ³•

rust

```rust
fn main() {
    let number = 3;
    
    match number {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        4 => println!("å››"),
        5 => println!("äº”"),
        _ => println!("å…¶ä»–"),  // _ æ˜¯é€šé…ç¬¦
    }
}
```

### Match æ˜¯è¡¨è¾¾å¼

rust

```rust
fn main() {
    let number = 2;
    
    // match è¿”å›å€¼
    let description = match number {
        1 => "ä¸€",
        2 => "äºŒ",
        3 => "ä¸‰",
        _ => "å…¶ä»–",
    };
    
    println!("æ•°å­—æ˜¯: {}", description);
}
```

### å„ç§æ¨¡å¼ç±»å‹

rust

```rust
fn describe_value(x: i32) {
    match x {
        // 1. å­—é¢å€¼æ¨¡å¼
        0 => println!("é›¶"),
        1 => println!("ä¸€"),
        
        // 2. èŒƒå›´æ¨¡å¼
        2..=10 => println!("2åˆ°10ä¹‹é—´"),
        
        // 3. å¤šä¸ªå€¼ï¼ˆä½¿ç”¨ |ï¼‰
        11 | 12 | 13 => println!("11ã€12æˆ–13"),
        
        // 4. å®ˆå«ï¼ˆifæ¡ä»¶ï¼‰
        n if n < 0 => println!("è´Ÿæ•°: {}", n),
        n if n > 100 => println!("å¤§äº100: {}", n),
        
        // 5. é€šé…ç¬¦
        _ => println!("å…¶ä»–å€¼"),
    }
}
```

### è§£æ„æ¨¡å¼

rust

```rust
// è§£æ„å…ƒç»„
fn tuple_match(pair: (i32, i32)) {
    match pair {
        (0, y) => println!("ç¬¬ä¸€ä¸ªæ˜¯0ï¼Œç¬¬äºŒä¸ªæ˜¯{}", y),
        (x, 0) => println!("ç¬¬ä¸€ä¸ªæ˜¯{}ï¼Œç¬¬äºŒä¸ªæ˜¯0", x),
        (x, y) => println!("({}, {})", x, y),
    }
}

// è§£æ„ç»“æ„ä½“
struct Point {
    x: i32,
    y: i32,
}

fn struct_match(point: Point) {
    match point {
        Point { x: 0, y: 0 } => println!("åŸç‚¹"),
        Point { x: 0, y } => println!("åœ¨yè½´ä¸Šï¼Œy = {}", y),
        Point { x, y: 0 } => println!("åœ¨xè½´ä¸Šï¼Œx = {}", x),
        Point { x, y } => println!("({}, {})", x, y),
    }
}

// è§£æ„æšä¸¾
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn enum_match(msg: Message) {
    match msg {
        Message::Quit => println!("é€€å‡º"),
        Message::Move { x, y } => println!("ç§»åŠ¨åˆ°({}, {})", x, y),
        Message::Write(text) => println!("å†™å…¥: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("æ”¹å˜é¢œè‰²ä¸ºRGB({}, {}, {})", r, g, b)
        }
    }
}
```

---

## 2. EXHAUSTIVENESSï¼ˆç©·å°½æ€§ï¼‰

**Match å¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½çš„æƒ…å†µï¼** è¿™æ˜¯ Rust çš„é‡è¦å®‰å…¨ç‰¹æ€§ã€‚

### ç¼–è¯‘å™¨å¼ºåˆ¶ç©·å°½æ€§

rust

```rust
fn main() {
    let x = 5;
    
    // âŒ é”™è¯¯ï¼šæ²¡æœ‰è¦†ç›–æ‰€æœ‰æƒ…å†µ
    // match x {
    //     1 => println!("ä¸€"),
    //     2 => println!("äºŒ"),
    // }  // ç¼–è¯‘é”™è¯¯ï¼šæ²¡æœ‰è¦†ç›–å…¶ä»–å€¼
    
    // âœ… æ­£ç¡®ï¼šä½¿ç”¨ _ æ•è·å…¶ä»–æƒ…å†µ
    match x {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        _ => println!("å…¶ä»–"),
    }
}
```

### æšä¸¾çš„ç©·å°½æ€§

rust

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    // âœ… å¿…é¡»å¤„ç†æ‰€æœ‰å˜ä½“
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

// âŒ å¦‚æœå°‘ä¸€ä¸ªä¼šç¼–è¯‘é”™è¯¯
// fn incomplete_match(coin: Coin) -> u8 {
//     match coin {
//         Coin::Penny => 1,
//         Coin::Nickel => 5,
//         Coin::Dime => 10,
//         // ç¼ºå°‘ Quarterï¼ç¼–è¯‘é”™è¯¯
//     }
// }
```

### Option çš„ç©·å°½æ€§

rust

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
        None => None,
    }  // âœ… è¦†ç›–äº† Some å’Œ None
}

// âŒ ç¼ºå°‘ None åˆ†æ”¯ä¼šæŠ¥é”™
// fn incomplete(x: Option<i32>) -> Option<i32> {
//     match x {
//         Some(i) => Some(i + 1),
//     }  // ç¼–è¯‘é”™è¯¯ï¼
// }
```

### ç©·å°½æ€§çš„å¥½å¤„

rust

```rust
// æ·»åŠ æ–°çš„æšä¸¾å˜ä½“æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæé†’ä½ æ›´æ–°æ‰€æœ‰ match
enum Status {
    Active,
    Inactive,
    // å‡è®¾åæ¥æ·»åŠ äº†ï¼š
    // Pending,  // æ‰€æœ‰ä½¿ç”¨ Status çš„ match éƒ½ä¼šæŠ¥é”™
}

fn check_status(status: Status) {
    match status {
        Status::Active => println!("æ´»è·ƒ"),
        Status::Inactive => println!("ä¸æ´»è·ƒ"),
        // å¦‚æœæ·»åŠ äº† Pendingï¼Œè¿™é‡Œä¼šç¼–è¯‘é”™è¯¯
        // å¼ºåˆ¶ä½ å¤„ç†æ–°æƒ…å†µ
    }
}
```

---

## 3. CATCH-ALLï¼ˆæ•è·æ‰€æœ‰ï¼‰

ä½¿ç”¨ `_` æˆ–å˜é‡åæ¥æ•è·æ‰€æœ‰æœªæ˜ç¡®åŒ¹é…çš„æƒ…å†µã€‚

### ä½¿ç”¨ `_` å¿½ç•¥å€¼

rust

```rust
fn main() {
    let x = 9;
    
    match x {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        _ => println!("å…¶ä»–æ•°å­—"),  // _ åŒ¹é…æ‰€æœ‰å‰©ä½™æƒ…å†µ
    }
}
```

### ä½¿ç”¨å˜é‡åæ•è·å€¼

rust

```rust
fn main() {
    let x = 9;
    
    match x {
        1 => println!("ä¸€"),
        2 => println!("äºŒ"),
        3 => println!("ä¸‰"),
        other => println!("å…¶ä»–æ•°å­—: {}", other),  // æ•è·å¹¶ä½¿ç”¨å€¼
    }
}
```


---

# 4. EXAMPLE: MATCH OPTION`<T>`ï¼ˆç¤ºä¾‹ï¼šåŒ¹é… Optionï¼‰

Option æ˜¯æœ€å¸¸ç”¨ match çš„ç±»å‹ä¹‹ä¸€ã€‚

åŸºæœ¬ Option åŒ¹é…



``` rust
fn main() {
    let some_number = Some(5);
    let no_number: Option<i32> = None;
    
    // å¤„ç† Some
    match some_number {
        Some(value) => println!("æœ‰å€¼: {}", value),
        None => println!("æ²¡æœ‰å€¼"),
    }
    
    // å¤„ç† None
    match no_number {
        Some(value) => println!("æœ‰å€¼: {}", value),
        None => println!("æ²¡æœ‰å€¼"),
    }
}
```

### ä½¿ç”¨ match è½¬æ¢ Option

rust

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
        None => None,
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    
    println!("{:?}", six);   // Some(6)
    println!("{:?}", none);  // None
}
```

### æå– Option ä¸­çš„å€¼

rust

```rust
fn get_value_or_default(opt: Option<i32>) -> i32 {
    match opt {
        Some(value) => value,
        None => 0,  // é»˜è®¤å€¼
    }
}

fn describe_option(opt: Option<String>) {
    match opt {
        Some(text) => println!("å†…å®¹: {}", text),
        None => println!("ç©ºå€¼"),
    }
}
```


---

## 5. EXAMPLE: MATCH RESULT<T, E>ï¼ˆç¤ºä¾‹ï¼šåŒ¹é… Resultï¼‰

Result æ˜¯å¦ä¸€ä¸ªå¸¸ç”¨ match çš„ç±»å‹ï¼Œç”¨äºé”™è¯¯å¤„ç†ã€‚

### åŸºæœ¬ Result åŒ¹é…

rust

```rust
fn main() {
    let result: Result<i32, String> = Ok(42);
    
    match result {
        Ok(value) => println!("æˆåŠŸ: {}", value),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
}
```

### æ–‡ä»¶æ“ä½œç¤ºä¾‹

rust

```rust
use std::fs::File;
use std::io::Read;

fn read_file(path: &str) -> Result<String, String> {
    let mut file = match File::open(path) {
        Ok(file) => file,
        Err(e) => return Err(format!("æ— æ³•æ‰“å¼€æ–‡ä»¶: {}", e)),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(format!("æ— æ³•è¯»å–æ–‡ä»¶: {}", e)),
    }
}

fn main() {
    match read_file("example.txt") {
        Ok(contents) => println!("æ–‡ä»¶å†…å®¹:\n{}", contents),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
}
```

### è§£æå’ŒéªŒè¯

rust

```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("é™¤æ•°ä¸èƒ½ä¸ºé›¶"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Ok(result) => println!("ç»“æœ: {}", result),
        Err(msg) => println!("é”™è¯¯: {}", msg),
    }
    
    match divide(10, 0) {
        Ok(result) => println!("ç»“æœ: {}", result),
        Err(msg) => println!("é”™è¯¯: {}", msg),  // è¾“å‡º: é”™è¯¯: é™¤æ•°ä¸èƒ½ä¸ºé›¶
    }
}
```

### é“¾å¼é”™è¯¯å¤„ç†

rust

```rust
fn process() -> Result<i32, String> {
    let step1 = match operation1() {
        Ok(val) => val,
        Err(e) => return Err(format!("æ­¥éª¤1å¤±è´¥: {}", e)),
    };
    
    let step2 = match operation2(step1) {
        Ok(val) => val,
        Err(e) => return Err(format!("æ­¥éª¤2å¤±è´¥: {}", e)),
    };
    
    Ok(step2)
}

// ä½¿ç”¨ ? è¿ç®—ç¬¦ç®€åŒ–ï¼ˆä¸‹ä¸€ä¸ªä¸»é¢˜ï¼‰
fn process_short() -> Result<i32, String> {
    let step1 = operation1()?;
    let step2 = operation2(step1)?;
    Ok(step2)
}
```

### ä¸åŒé”™è¯¯ç±»å‹çš„åŒ¹é…

rust

```rust
use std::num::ParseIntError;

fn parse_and_double(s: &str) -> Result<i32, ParseIntError> {
    match s.parse::<i32>() {
        Ok(n) => Ok(n * 2),
        Err(e) => Err(e),
    }
}

fn handle_parse() {
    match parse_and_double("21") {
        Ok(n) => println!("ç»“æœ: {}", n),
        Err(e) => println!("è§£æé”™è¯¯: {}", e),
    }
}
```

---


## Match vs if let

rust

```rust
// match - ç©·å°½æ‰€æœ‰æƒ…å†µ
let some_value = Some(3);
match some_value {
    Some(3) => println!("ä¸‰"),
    _ => (),
}

// if let - åªå…³å¿ƒä¸€ç§æƒ…å†µ
if let Some(3) = some_value {
    println!("ä¸‰");
}
```