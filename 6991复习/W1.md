åœ¨Rustä¸­ï¼Œ`let`è¯­å¥åˆ›å»ºçš„æ˜¯**ç»‘å®š**è€Œä¸æ˜¯ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„"å˜é‡"ã€‚è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µåŒºåˆ«ï¼š

rust

```rust
let x = 5;  // å°†å€¼5ç»‘å®šåˆ°åç§°xä¸Š
```

**å…³é”®ç‚¹ï¼š**

- ç»‘å®šæ„å‘³ç€å°†ä¸€ä¸ªå€¼ä¸ä¸€ä¸ªåç§°å…³è”èµ·æ¥
- è¿™ä½“ç°äº†Rustçš„æ‰€æœ‰æƒç³»ç»Ÿæ€æƒ³
- ç»‘å®šå¯ä»¥æ˜¯ä¸å¯å˜çš„ï¼ˆé»˜è®¤ï¼‰æˆ–å¯å˜çš„ï¼ˆä½¿ç”¨`mut`å…³é”®å­—ï¼‰

rust

```rust
let x = 10;        // ä¸å¯å˜ç»‘å®š
let mut y = 20;    // å¯å˜ç»‘å®š
y = 30;            // å¯ä»¥ä¿®æ”¹
```

## 2. MUTABILITYï¼ˆå¯å˜æ€§ï¼‰

Rustä¸­çš„ç»‘å®š**é»˜è®¤æ˜¯ä¸å¯å˜çš„**ï¼Œè¿™æ˜¯Rustå®‰å…¨æ€§è®¾è®¡çš„æ ¸å¿ƒç‰¹æ€§ï¼š

rust

```rust
let x = 5;
x = 6;  // âŒ é”™è¯¯ï¼xæ˜¯ä¸å¯å˜çš„

let mut y = 5;
y = 6;  // âœ… æ­£ç¡®ï¼yæ˜¯å¯å˜çš„
```

**è®¾è®¡ç†å¿µï¼š**

- ä¸å¯å˜æ€§æ˜¯é»˜è®¤çš„ï¼Œé¼“åŠ±æ›´å®‰å…¨çš„ä»£ç 
- éœ€è¦å¯å˜æ€§æ—¶å¿…é¡»æ˜¾å¼å£°æ˜`mut`
- è¿™å¸®åŠ©é˜²æ­¢æ„å¤–ä¿®æ”¹æ•°æ®
- ä½¿ä»£ç æ›´å®¹æ˜“æ¨ç†å’Œç»´æŠ¤

## 3. SHADOWINGï¼ˆé®è”½ï¼‰

Shadowingå…è®¸ä½ ç”¨ç›¸åŒçš„åç§°å£°æ˜æ–°çš„ç»‘å®šï¼Œ**é®è”½**ä¹‹å‰çš„ç»‘å®šï¼š

rust

```rust
let x = 5;
let x = x + 1;     // åˆ›å»ºæ–°çš„xï¼Œé®è”½äº†æ—§çš„x
let x = x * 2;     // å†æ¬¡é®è”½
println!("{}", x); // è¾“å‡º: 12
```

**Shadowing vs å¯å˜æ€§çš„åŒºåˆ«ï¼š**

rust

```rust
// Shadowing - å¯ä»¥æ”¹å˜ç±»å‹
let spaces = "   ";
let spaces = spaces.len();  // âœ… ä»&strå˜ä¸ºusize

// å¯å˜æ€§ - ä¸èƒ½æ”¹å˜ç±»å‹
let mut spaces = "   ";
spaces = spaces.len();      // âŒ é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
```

**Shadowingçš„ä¼˜åŠ¿ï¼š**

- å¯ä»¥æ”¹å˜å€¼çš„ç±»å‹
- å¯ä»¥é‡ç”¨å˜é‡å
- æ¯æ¬¡shadowingéƒ½åˆ›å»ºæ–°çš„ä¸å¯å˜ç»‘å®š
- åœ¨ä¸åŒä½œç”¨åŸŸä¸­å¯ä»¥æœ‰ä¸åŒçš„å«ä¹‰

## 4. ASIDE: CONSTANTSï¼ˆè¡¥å……ï¼šå¸¸é‡ï¼‰

å¸¸é‡ä¸ä¸å¯å˜ç»‘å®šæœ‰é‡è¦åŒºåˆ«ï¼š

rust

```rust
const MAX_POINTS: u32 = 100_000;
```

**å¸¸é‡çš„ç‰¹ç‚¹ï¼š**

- ä½¿ç”¨`const`å…³é”®å­—å£°æ˜
- **å¿…é¡»æ ‡æ³¨ç±»å‹**
- å¿…é¡»åœ¨ç¼–è¯‘æ—¶å°±èƒ½ç¡®å®šå€¼
- å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
- å‘½åçº¦å®šï¼šå…¨å¤§å†™å­—æ¯ï¼Œä¸‹åˆ’çº¿åˆ†éš”

---

**æ€»ç»“ï¼š** è¿™å››ä¸ªæ¦‚å¿µå…±åŒæ„æˆäº†Rustå˜é‡ç³»ç»Ÿçš„åŸºç¡€ã€‚ç»‘å®šå¼ºè°ƒæ‰€æœ‰æƒï¼Œé»˜è®¤ä¸å¯å˜æ€§ä¿è¯å®‰å…¨ï¼Œshadowingæä¾›çµæ´»æ€§ï¼Œè€Œå¸¸é‡æä¾›çœŸæ­£çš„ç¼–è¯‘æ—¶å¸¸é‡ã€‚è¿™äº›è®¾è®¡ä½¿Rustæ—¢å®‰å…¨åˆçµæ´»ã€‚






## 1. INTEGER TYPESï¼ˆæ•´æ•°ç±»å‹ - FIXED, ARCHï¼‰

Rustæä¾›äº†å¤šç§æ•´æ•°ç±»å‹ï¼Œåˆ†ä¸º**å›ºå®šå¤§å°ç±»å‹**å’Œ**æ¶æ„ç›¸å…³ç±»å‹**ã€‚

### å›ºå®šå¤§å°æ•´æ•°ç±»å‹ï¼ˆFixed-sizeï¼‰

**æœ‰ç¬¦å·æ•´æ•°ï¼ˆsignedï¼‰ï¼š** å¯ä»¥è¡¨ç¤ºæ­£æ•°ã€è´Ÿæ•°å’Œé›¶

|ç±»å‹|å¤§å°|èŒƒå›´|
|---|---|---|
|`i8`|8ä½|-128 åˆ° 127|
|`i16`|16ä½|-32,768 åˆ° 32,767|
|`i32`|32ä½|-2,147,483,648 åˆ° 2,147,483,647|
|`i64`|64ä½|-9,223,372,036,854,775,808 åˆ° 9,223,372,036,854,775,807|
|`i128`|128ä½|éå¸¸å¤§çš„èŒƒå›´|

**æ— ç¬¦å·æ•´æ•°ï¼ˆunsignedï¼‰ï¼š** åªèƒ½è¡¨ç¤ºéè´Ÿæ•°

|ç±»å‹|å¤§å°|èŒƒå›´|
|---|---|---|
|`u8`|8ä½|0 åˆ° 255|
|`u16`|16ä½|0 åˆ° 65,535|
|`u32`|32ä½|0 åˆ° 4,294,967,295|
|`u64`|64ä½|0 åˆ° 18,446,744,073,709,551,615|
|`u128`|128ä½|éå¸¸å¤§çš„èŒƒå›´|

**ç¤ºä¾‹ä»£ç ï¼š**

rust

```rust
// æ•´æ•°å­—é¢é‡å¯ä»¥ä½¿ç”¨ç±»å‹åç¼€
let x = 42u8;               // u8ç±»å‹
let y = 100i32;             // i32ç±»å‹
```

### æ¶æ„ç›¸å…³ç±»å‹ï¼ˆArchitecture-dependentï¼‰

|ç±»å‹|è¯´æ˜|
|---|---|
|`isize`|æœ‰ç¬¦å·ï¼Œå¤§å°å–å†³äºCPUæ¶æ„ï¼ˆ32ä½ç³»ç»Ÿä¸Šæ˜¯32ä½ï¼Œ64ä½ç³»ç»Ÿä¸Šæ˜¯64ä½ï¼‰|
|`usize`|æ— ç¬¦å·ï¼Œå¤§å°å–å†³äºCPUæ¶æ„|

æŒ‡é’ˆè¿ç®—å’Œå†…å­˜åœ°å€ä½¿ç”¨isize/usize



---

## 2. FLOATING POINT TYPESï¼ˆæµ®ç‚¹æ•°ç±»å‹ï¼‰

Rustæœ‰ä¸¤ç§æµ®ç‚¹æ•°ç±»å‹ï¼Œéƒ½æ˜¯**æœ‰ç¬¦å·**çš„ï¼š

|ç±»å‹|å¤§å°|ç²¾åº¦|
|---|---|---|
|`f32`|32ä½|å•ç²¾åº¦|
|`f64`|64ä½|åŒç²¾åº¦ï¼ˆé»˜è®¤ï¼‰|


**æ³¨æ„äº‹é¡¹ï¼š**

rust

```rust
// æµ®ç‚¹æ•°æ¯”è¾ƒè¦å°å¿ƒ
let a = 0.1 + 0.2;
let b = 0.3;
// a == b å¯èƒ½æ˜¯falseï¼Œå› ä¸ºæµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜

// æ¨èä½¿ç”¨epsilonæ¯”è¾ƒ
let epsilon = 0.00001;
if (a - b).abs() < epsilon {
    println!("è¿‘ä¼¼ç›¸ç­‰");
}
```

---

## 3. BOOLEANï¼ˆå¸ƒå°”ç±»å‹ï¼‰

å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`ï¼Œå ç”¨**1ä¸ªå­—èŠ‚**ã€‚

rust

```rust
let t: bool = true;
let f: bool = false;

// å¸¸ç”¨äºæ¡ä»¶åˆ¤æ–­
if t {
    println!("è¿™æ˜¯çœŸçš„ï¼");
}

// å¸ƒå°”è¿ç®—
let and = true && false;    // false
let or = true || false;     // true
let not = !true;            // false

// æ¯”è¾ƒè¿ç®—è¿”å›å¸ƒå°”å€¼
let greater = 5 > 3;        // true
let equal = 5 == 5;         // true
```

---

## 4. CHARACTERï¼ˆå­—ç¬¦ç±»å‹ï¼‰

Rustçš„`char`ç±»å‹ä»£è¡¨ä¸€ä¸ª**Unicodeæ ‡é‡å€¼**ï¼Œå ç”¨**4ä¸ªå­—èŠ‚**ã€‚

rust

```rust
let c: char = 'z';
let z: char = 'â„¤';
let heart_eyed_cat: char = 'ğŸ˜»';
let chinese: char = 'ä¸­';

// æ³¨æ„ï¼šcharä½¿ç”¨å•å¼•å·ï¼Œå­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å·
let character = 'A';    // char
let string = "A";       // &str
```



---

## ç±»å‹æ¨æ–­ä¸æ˜¾å¼æ ‡æ³¨

Rustæœ‰å¼ºå¤§çš„ç±»å‹æ¨æ–­èƒ½åŠ›ï¼š

rust

```rust
// ç±»å‹æ¨æ–­
let x = 5;          // ç¼–è¯‘å™¨æ¨æ–­ä¸ºi32
let y = 2.0;        // ç¼–è¯‘å™¨æ¨æ–­ä¸ºf64

// æ˜¾å¼ç±»å‹æ ‡æ³¨
let a: i64 = 5;
let b: f32 = 2.0;
let c: bool = true;
let d: char = 'x';

// ä¸Šä¸‹æ–‡å¸®åŠ©æ¨æ–­
let mut vec = Vec::new();
vec.push(1);        // ç¼–è¯‘å™¨æ¨æ–­vecæ˜¯Vec<i32>
```








## 1. TUPLES, ARRAYSï¼ˆå…ƒç»„å’Œæ•°ç»„ï¼‰

### å…ƒç»„ï¼ˆTuplesï¼‰

å…ƒç»„æ˜¯å°†**å¤šä¸ªä¸åŒç±»å‹**çš„å€¼ç»„åˆæˆä¸€ä¸ªå¤åˆç±»å‹çš„æ–¹å¼ã€‚

**åŸºæœ¬è¯­æ³•ï¼š**

rust

```rust
// åˆ›å»ºå…ƒç»„
let tup: (i32, f64, u8) = (500, 6.4, 1);

// è§£æ„å…ƒç»„
let (x, y, z) = tup;
println!("y çš„å€¼æ˜¯: {}", y);  // è¾“å‡º: 6.4

// é€šè¿‡ç´¢å¼•è®¿é—®
let five_hundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;
```

**å…ƒç»„çš„ç‰¹ç‚¹ï¼š**

rust

```rust
// å›ºå®šé•¿åº¦ï¼Œåˆ›å»ºåä¸èƒ½æ”¹å˜å¤§å°
let tuple = (1, 2, 3);

// å¯ä»¥åŒ…å«ä¸åŒç±»å‹
let mixed = (42, "hello", 3.14, true);

// å¯ä»¥åµŒå¥—
let nested = ((1, 2), (3, 4));

// ç©ºå…ƒç»„ç§°ä¸ºunitï¼Œå†™ä½œ ()
let unit = ();
```

**å®é™…åº”ç”¨ï¼š**

rust

```rust
// å‡½æ•°è¿”å›å¤šä¸ªå€¼
fn calculate(x: i32) -> (i32, i32, i32) {
    (x + 1, x * 2, x * x)
}

fn main() {
    let (add, mul, square) = calculate(5);
    println!("åŠ 1: {}, ä¹˜2: {}, å¹³æ–¹: {}", add, mul, square);
}

// äº¤æ¢ä¸¤ä¸ªå€¼
let mut a = 1;
let mut b = 2;
(a, b) = (b, a);  // äº¤æ¢
```

### æ•°ç»„ï¼ˆArraysï¼‰

æ•°ç»„æ˜¯**å›ºå®šé•¿åº¦**ã€**ç›¸åŒç±»å‹**å…ƒç´ çš„é›†åˆã€‚

**åŸºæœ¬è¯­æ³•ï¼š**

rust

```rust
// åˆ›å»ºæ•°ç»„
let arr: [i32; 5] = [1, 2, 3, 4, 5];

// ç®€å†™ï¼šæ‰€æœ‰å…ƒç´ ç›¸åŒ
let arr = [3; 5];  // ç­‰åŒäº [3, 3, 3, 3, 3]

// è®¿é—®å…ƒç´ 
let first = arr[0];
let second = arr[1];
```

**æ•°ç»„çš„ç‰¹ç‚¹ï¼š**

rust

```rust
// å›ºå®šé•¿åº¦ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
let months = ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", 
              "å…­æœˆ", "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", 
              "åä¸€æœˆ", "åäºŒæœˆ"];

// ç±»å‹æ ‡æ³¨ï¼š[ç±»å‹; é•¿åº¦]
let numbers: [i32; 3] = [1, 2, 3];

// è·å–é•¿åº¦
let len = numbers.len();  // 3
```

**æ•°ç»„è¶Šç•Œæ£€æŸ¥ï¼š**

rust

```rust
let arr = [1, 2, 3, 4, 5];

// è¿è¡Œæ—¶ä¼španic
// let element = arr[10];  // ç´¢å¼•è¶Šç•Œï¼

// å®‰å…¨è®¿é—®
if let Some(value) = arr.get(2) {
    println!("å€¼æ˜¯: {}", value);
}
```

**æ•°ç»„éå†ï¼š**

rust

```rust
let arr = [10, 20, 30, 40, 50];

// æ–¹æ³•1ï¼šforå¾ªç¯
for element in arr {
    println!("å€¼: {}", element);
}

// æ–¹æ³•2ï¼šå¸¦ç´¢å¼•
for (index, value) in arr.iter().enumerate() {
    println!("ç´¢å¼• {}: å€¼ {}", index, value);
}
```

---

## 2. STRUCTS, ENUMSï¼ˆç»“æ„ä½“å’Œæšä¸¾ï¼‰

### ç»“æ„ä½“ï¼ˆStructsï¼‰

ç»“æ„ä½“ç”¨äºåˆ›å»º**è‡ªå®šä¹‰æ•°æ®ç±»å‹**ï¼Œå°†ç›¸å…³æ•°æ®ç»„åˆåœ¨ä¸€èµ·ã€‚

**ä¸‰ç§ç»“æ„ä½“ç±»å‹ï¼š**

**1. å‘½åå­—æ®µç»“æ„ä½“ï¼š**

rust

```rust
// å®šä¹‰ç»“æ„ä½“
struct User {
    username: String,
    email: String,
    age: u32,
    active: bool,
}

// åˆ›å»ºå®ä¾‹
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("å¼ ä¸‰"),
    age: 25,
    active: true,
};

// è®¿é—®å­—æ®µ
println!("ç”¨æˆ·å: {}", user1.username);

// å¯å˜å®ä¾‹
let mut user2 = User {
    email: String::from("another@example.com"),
    username: String::from("æå››"),
    age: 30,
    active: true,
};
user2.age = 31;  // ä¿®æ”¹å­—æ®µ
```

**2. å…ƒç»„ç»“æ„ä½“ï¼š**

rust

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// è®¿é—®å­—æ®µ
println!("çº¢è‰²å€¼: {}", black.0);
```

**3. å•å…ƒç»“æ„ä½“ï¼ˆæ— å­—æ®µï¼‰ï¼š**

rust

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;
```

**ç»“æ„ä½“æ–¹æ³•ï¼š**

rust

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•ï¼ˆéœ€è¦selfï¼‰
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // å…³è”å‡½æ•°ï¼ˆä¸éœ€è¦selfï¼‰
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    println!("é¢ç§¯: {}", rect.area());
    
    let sq = Rectangle::square(20);
}
```

### æšä¸¾ï¼ˆEnumsï¼‰

æšä¸¾å…è®¸ä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œå®ƒçš„å€¼å¯ä»¥æ˜¯**å‡ ä¸ªå˜ä½“ä¹‹ä¸€**ã€‚

**åŸºæœ¬æšä¸¾ï¼š**

rust

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

let direction = Direction::North;
```

**å¸¦æ•°æ®çš„æšä¸¾ï¼š**

rust

```rust
enum Message {
    Quit,                       // æ— æ•°æ®
    Move { x: i32, y: i32 },   // å‘½åå­—æ®µ
    Write(String),              // å•ä¸ªå€¼
    ChangeColor(i32, i32, i32), // å…ƒç»„
}

let msg1 = Message::Quit;
let msg2 = Message::Move { x: 10, y: 20 };
let msg3 = Message::Write(String::from("hello"));
let msg4 = Message::ChangeColor(255, 0, 0);
```

**Optionæšä¸¾ï¼ˆæœ€é‡è¦çš„æšä¸¾ä¹‹ä¸€ï¼‰ï¼š**
è¡¨ç¤ºâ€œå¯èƒ½æœ‰å€¼ / å¯èƒ½æ²¡å€¼â€çš„ç±»å‹
rust

```rust
enum Option<T> {
    Some(T),
    None,
}

// ä½¿ç”¨Optionå¤„ç†å¯èƒ½ä¸å­˜åœ¨çš„å€¼
let some_number = Some(5);
let some_string = Some("å­—ç¬¦ä¸²");
let absent_number: Option<i32> = None;

// ä½¿ç”¨matchå¤„ç†
match some_number {
    Some(value) => println!("å€¼æ˜¯: {}", value),
    None => println!("æ²¡æœ‰å€¼"),
}
```

**Resultæšä¸¾ï¼ˆé”™è¯¯å¤„ç†ï¼‰ï¼š**

rust

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("é™¤æ•°ä¸èƒ½ä¸ºé›¶"))
    } else {
        Ok(a / b)
    }
}

match divide(10, 2) {
    Ok(result) => println!("ç»“æœ: {}", result),
    Err(err) => println!("é”™è¯¯: {}", err),
}
```

**æšä¸¾æ–¹æ³•ï¼š**

rust

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

impl TrafficLight {
    fn time(&self) -> u32 {
        match self {
            TrafficLight::Red => 60,
            TrafficLight::Yellow => 3,
            TrafficLight::Green => 90,
        }
    }
}

let light = TrafficLight::Red;
println!("æ—¶é•¿: {} ç§’", light.time());
```

---

## 3. ASIDE: PERVASIVE MUTABILITYï¼ˆè¡¥å……ï¼šæ™®éå¯å˜æ€§ï¼‰

åœ¨å¾ˆå¤šè¯­è¨€é‡Œï¼Œæ‰€æœ‰æ•°æ®éƒ½é»˜è®¤æ˜¯å¯å˜çš„ï¼Œå¯¼è‡´ bug éš¾ä»¥è¿½è¸ªï¼ŒçŠ¶æ€éš¾ä»¥ç®¡ç†ã€‚
Rust çš„è®¾è®¡ç›®æ ‡ï¼Œå°±æ˜¯è®©å¯å˜æ€§å˜å¾—å—æ§ã€æ˜¾å¼ã€å¯éªŒè¯ã€‚
rustå¦‚ä½•è§£å†³çš„å‘¢ï¼š
é»˜è®¤ä¸å¯å˜ï¼ˆimmutable by defaultï¼‰
åŒæ—¶åªèƒ½ï¼š

å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼ˆ&Tï¼‰
    
æˆ– 1 ä¸ªå¯å˜å¼•ç”¨ï¼ˆ&mut Tï¼‰


---

## 4. ASIDE: UNITï¼ˆè¡¥å……ï¼šå•å…ƒç±»å‹ï¼‰

**å•å…ƒç±»å‹ `()`ï¼š**

å•å…ƒç±»å‹æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ï¼Œåªæœ‰ä¸€ä¸ªå€¼ï¼Œä¹Ÿå†™ä½œ `()`ã€‚

**ç”¨é€”ï¼š**

rust

```rust
// 1. æ— è¿”å›å€¼çš„å‡½æ•°
fn do_something() -> () {
    println!("åšäº›äº‹æƒ…");
    // éšå¼è¿”å› ()
}

// ç­‰åŒäº
fn do_something() {
    println!("åšäº›äº‹æƒ…");
}

// 2. åœ¨æ³›å‹ä¸­ä½œä¸ºå ä½ç¬¦
let empty_tuple = ();

// 3. è¡¨ç¤º"æ— æ„ä¹‰"çš„å€¼
let result: Result<(), String> = Ok(());

// 4. æ•°ç»„å’Œå‘é‡
let empty_array: [(); 0] = [];
```


---

**è¡¨è¾¾å¼ï¼ˆExpressionï¼‰ä¸è¯­å¥ï¼ˆStatementï¼‰**çš„åŒºåˆ«ï¼š


1. VALUE PRODUCTIONï¼ˆå€¼çš„äº§ç”Ÿï¼‰
è¡¨è¾¾å¼ï¼šæ²¡æœ‰åˆ†å·ï¼Œä¼šè¿”å›å€¼
è¯­å¥ï¼šæœ‰åˆ†å·ï¼Œä¸è¿”å›å€¼

## 2. IMPLICATIONS ON NESTINGï¼ˆå¯¹åµŒå¥—çš„å½±å“ï¼‰

è¡¨è¾¾å¼å¯ä»¥åµŒå¥—ï¼Œè€Œè¯­å¥ä¸èƒ½ä½œä¸ºå€¼ä½¿ç”¨ã€‚
## 3. ITEM DECLARATIONSï¼ˆé¡¹å£°æ˜ï¼‰

é¡¹ï¼ˆItemsï¼‰æ˜¯åœ¨æ¨¡å—çº§åˆ«å®šä¹‰çš„ç»„ä»¶ï¼ŒåŒ…æ‹¬ï¼š
## 4. LET STATEMENTSï¼ˆletè¯­å¥ï¼‰

`let`è¯­å¥ç”¨äºåˆ›å»ºç»‘å®šï¼Œæ˜¯ä¸€ç§è¯­å¥ï¼Œä¸è¿”å›å€¼ã€‚

## 5. EXPRESSION STATEMENTSï¼ˆè¡¨è¾¾å¼è¯­å¥ï¼‰

è¡¨è¾¾å¼åé¢åŠ åˆ†å·å°±å˜æˆäº†è¯­å¥ã€‚







# Rustä¸­çš„**å‡½æ•°ï¼ˆFunctionsï¼‰**ï¼š

## 1. PARAMETERSï¼ˆå‚æ•°ï¼‰

### åŸºæœ¬å‚æ•°è¯­æ³•

rust

```rust
// å‡½æ•°å®šä¹‰ï¼šå¿…é¡»æ ‡æ³¨å‚æ•°ç±»å‹
fn greet(name: String) {
    println!("ä½ å¥½, {}!", name);
}

// å¤šä¸ªå‚æ•°
fn add(x: i32, y: i32) {
    println!("å’Œæ˜¯: {}", x + y);
}

// ä¸åŒç±»å‹çš„å‚æ•°
fn print_info(name: String, age: u32, active: bool) {
    println!("{} ä»Šå¹´ {} å²ï¼ŒçŠ¶æ€: {}", name, age, active);
}
```

### å‚æ•°ä¼ é€’æ–¹å¼

**1. æŒ‰å€¼ä¼ é€’ï¼ˆé»˜è®¤ï¼‰ï¼š**

rust

```rust
fn consume(s: String) {
    println!("{}", s);
    // s çš„æ‰€æœ‰æƒè¢«è½¬ç§»åˆ°è¿™é‡Œ
}

fn main() {
    let text = String::from("hello");
    consume(text);
    // println!("{}", text);  // âŒ é”™è¯¯ï¼textå·²è¢«ç§»åŠ¨
}
```

**2. å¼•ç”¨ä¼ é€’ï¼ˆå€Ÿç”¨ï¼‰ï¼š**

rust

```rust
// ä¸å¯å˜å¼•ç”¨
fn read(s: &String) {
    println!("{}", s);
    // åªèƒ½è¯»å–ï¼Œä¸èƒ½ä¿®æ”¹
}

// å¯å˜å¼•ç”¨
fn modify(s: &mut String) {
    s.push_str(" world");
}

fn main() {
    let text = String::from("hello");
    read(&text);              // å€Ÿç”¨
    println!("{}", text);     // âœ… textä»ç„¶æœ‰æ•ˆ
    
    let mut text2 = String::from("hello");
    modify(&mut text2);       // å¯å˜å€Ÿç”¨
    println!("{}", text2);    // è¾“å‡º: hello world
}
```

**3. Copyç±»å‹ï¼š**

rust

```rust
// å¯¹äºå®ç°äº†Copy traitçš„ç±»å‹ï¼ˆå¦‚i32ï¼‰ï¼Œä¼šè‡ªåŠ¨å¤åˆ¶
fn square(x: i32) -> i32 {
    x * x
}

fn main() {
    let num = 5;
    let result = square(num);
    println!("num: {}, result: {}", num, result);  // âœ… numä»ç„¶æœ‰æ•ˆ
}
```

### å‚æ•°æ¨¡å¼åŒ¹é…

rust

```rust
// å…ƒç»„å‚æ•°è§£æ„
fn print_coordinates((x, y): (i32, i32)) {
    println!("åæ ‡: ({}, {})", x, y);
}

// ç»“æ„ä½“å‚æ•°è§£æ„
struct Point {
    x: i32,
    y: i32,
}

fn print_point(Point { x, y }: Point) {
    println!("ç‚¹: ({}, {})", x, y);
}

fn main() {
    print_coordinates((10, 20));
    print_point(Point { x: 5, y: 10 });
}
```

---

## 2. RETURN VALUESï¼ˆè¿”å›å€¼ï¼‰

### åŸºæœ¬è¿”å›è¯­æ³•

rust

```rust
// æ˜¾å¼æ ‡æ³¨è¿”å›ç±»å‹
fn add(x: i32, y: i32) -> i32 {
    x + y  // æ²¡æœ‰åˆ†å·ï¼è¿™æ˜¯è¡¨è¾¾å¼
}

// ä½¿ç”¨returnå…³é”®å­—
fn subtract(x: i32, y: i32) -> i32 {
    return x - y;  // æ˜¾å¼è¿”å›
}

// æ— è¿”å›å€¼ï¼ˆè¿”å›å•å…ƒç±»å‹()ï¼‰
fn print_message(msg: &str) {
    println!("{}", msg);
    // éšå¼è¿”å›()
}

// æ˜¾å¼æ ‡æ³¨()
fn do_nothing() -> () {
    // ä»€ä¹ˆéƒ½ä¸åš
}
```

### è¿”å›å¤æ‚ç±»å‹

rust

```rust
// è¿”å›å…ƒç»„
fn swap(x: i32, y: i32) -> (i32, i32) {
    (y, x)
}

// è¿”å›ç»“æ„ä½“
struct Rectangle {
    width: u32,
    height: u32,
}

fn create_square(size: u32) -> Rectangle {
    Rectangle {
        width: size,
        height: size,
    }
}

// è¿”å›Option
fn divide(x: i32, y: i32) -> Option<i32> {
    if y == 0 {
        None
    } else {
        Some(x / y)
    }
}

// è¿”å›Result
fn parse_number(s: &str) -> Result<i32, String> {
    match s.parse::<i32>() {
        Ok(n) => Ok(n),
        Err(_) => Err(String::from("è§£æå¤±è´¥")),
    }
}
```

### è¿”å›å¼•ç”¨

rust

```rust
// è¿”å›å¼•ç”¨éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn first_element<'a>(list: &'a Vec<i32>) -> &'a i32 {
    &list[0]
}

// è¿”å›å¯å˜å¼•ç”¨
fn first_element_mut<'a>(list: &'a mut Vec<i32>) -> &'a mut i32 {
    &mut list[0]
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    let first = first_element(&numbers);
    println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", first);
}
```

---

## 3. EARLY-RETURNï¼ˆæå‰è¿”å›ï¼‰

æå‰è¿”å›ç”¨äºåœ¨æ»¡è¶³ç‰¹å®šæ¡ä»¶æ—¶ç«‹å³é€€å‡ºå‡½æ•°ã€‚

### ä½¿ç”¨returnå…³é”®å­—

rust

```rust
fn check_positive(n: i32) -> String {
    if n < 0 {
        return String::from("è´Ÿæ•°");  // æå‰è¿”å›
    }
    
    if n == 0 {
        return String::from("é›¶");    // æå‰è¿”å›
    }
    
    String::from("æ­£æ•°")  // æ­£å¸¸è¿”å›
}
```

### é”™è¯¯å¤„ç†ä¸­çš„æå‰è¿”å›

rust

```rust
fn process_file(path: &str) -> Result<String, String> {
    // æ£€æŸ¥è·¯å¾„
    if path.is_empty() {
        return Err(String::from("è·¯å¾„ä¸ºç©º"));
    }
    
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if !path.ends_with(".txt") {
        return Err(String::from("ä¸æ˜¯æ–‡æœ¬æ–‡ä»¶"));
    }
    
    // æ­£å¸¸å¤„ç†
    Ok(String::from("å¤„ç†æˆåŠŸ"))
}
```

### ä½¿ç”¨?è¿ç®—ç¬¦ï¼ˆæå‰è¿”å›é”™è¯¯ï¼‰

rust

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;  // å¦‚æœå¤±è´¥ï¼Œæå‰è¿”å›é”™è¯¯
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;  // å¦‚æœå¤±è´¥ï¼Œæå‰è¿”å›é”™è¯¯
    Ok(contents)  // æˆåŠŸè¿”å›
}
```

### Guardå­å¥æ¨¡å¼

rust

```rust
fn process(value: Option<i32>) -> i32 {
    // Guardå­å¥ï¼šæå‰å¤„ç†ç‰¹æ®Šæƒ…å†µ
    let Some(v) = value else {
        return 0;  // æå‰è¿”å›é»˜è®¤å€¼
    };
    
    // æ­£å¸¸å¤„ç†
    v * 2
}

// ä¼ ç»Ÿå†™æ³•å¯¹æ¯”
fn process_old(value: Option<i32>) -> i32 {
    match value {
        Some(v) => v * 2,
        None => 0,
    }
}
```

---

## 4. EXPRESSION-RETURNï¼ˆè¡¨è¾¾å¼è¿”å›ï¼‰

Rustä¸­å‡½æ•°çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼è‡ªåŠ¨ä½œä¸ºè¿”å›å€¼ï¼Œè¿™æ˜¯Rustçš„æ ¸å¿ƒç‰¹æ€§ã€‚

### éšå¼è¿”å›ï¼ˆæ¨èï¼‰

rust

```rust
// âœ… Rusté£æ ¼ï¼šä½¿ç”¨è¡¨è¾¾å¼è¿”å›
fn add(x: i32, y: i32) -> i32 {
    x + y  // æ²¡æœ‰åˆ†å·ï¼Œä½œä¸ºè¿”å›å€¼
}

// âœ… ä½¿ç”¨å—è¡¨è¾¾å¼
fn complex_calculation(x: i32) -> i32 {
    let doubled = x * 2;
    let squared = x * x;
    doubled + squared  // æœ€åçš„è¡¨è¾¾å¼æ˜¯è¿”å›å€¼
}

// âœ… ifè¡¨è¾¾å¼è¿”å›
fn max(x: i32, y: i32) -> i32 {
    if x > y {
        x
    } else {
        y
    }
}

// âœ… matchè¡¨è¾¾å¼è¿”å›
fn describe(n: i32) -> &'static str {
    match n {
        0 => "é›¶",
        1..=10 => "å°æ•°",
        11..=100 => "ä¸­æ•°",
        _ => "å¤§æ•°",
    }
}
```

### æ˜¾å¼è¿”å› vs è¡¨è¾¾å¼è¿”å›

rust

```rust
// æ˜¾å¼returnï¼ˆé€‚ç”¨äºæå‰è¿”å›ï¼‰
fn validate(n: i32) -> Result<i32, String> {
    if n < 0 {
        return Err(String::from("ä¸èƒ½ä¸ºè´Ÿæ•°"));
    }
    Ok(n)
}

// è¡¨è¾¾å¼è¿”å›ï¼ˆæ›´ç®€æ´ï¼‰
fn validate_v2(n: i32) -> Result<i32, String> {
    if n < 0 {
        Err(String::from("ä¸èƒ½ä¸ºè´Ÿæ•°"))
    } else {
        Ok(n)
    }
}
```

### å¸¸è§é”™è¯¯

rust

```rust
// âŒ é”™è¯¯ï¼šåŠ äº†åˆ†å·
fn add_wrong(x: i32, y: i32) -> i32 {
    x + y;  // åˆ†å·æŠŠè¡¨è¾¾å¼å˜æˆäº†è¯­å¥ï¼
            // å‡½æ•°å®é™…è¿”å›()
}

// âœ… æ­£ç¡®ï¼šæ²¡æœ‰åˆ†å·
fn add_correct(x: i32, y: i32) -> i32 {
    x + y
}

// âœ… æˆ–è€…ä½¿ç”¨æ˜¾å¼return
fn add_explicit(x: i32, y: i32) -> i32 {
    return x + y;  // returnè¯­å¥å¯ä»¥æœ‰åˆ†å·
}
```