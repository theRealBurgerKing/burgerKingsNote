åœ¨Rustä¸­ï¼Œ`let`è¯­å¥åˆ›å»ºçš„æ˜¯**ç»‘å®š**è€Œä¸æ˜¯ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„"å˜é‡"ã€‚è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µåŒºåˆ«ï¼š

rust

```rust
let x = 5;  // å°†å€¼5ç»‘å®šåˆ°åç§°xä¸Š
```

**å…³é”®ç‚¹ï¼š**

- ç»‘å®šæ„å‘³ç€å°†ä¸€ä¸ªå€¼ä¸ä¸€ä¸ªåç§°å…³è”èµ·æ¥
- è¿™ä½“ç°äº†Rustçš„æ‰€æœ‰æƒç³»ç»Ÿæ€æƒ³
- ç»‘å®šå¯ä»¥æ˜¯ä¸å¯å˜çš„ï¼ˆé»˜è®¤ï¼‰æˆ–å¯å˜çš„ï¼ˆä½¿ç”¨`mut`å…³é”®å­—ï¼‰

rust

```rust
let x = 10;        // ä¸å¯å˜ç»‘å®š
let mut y = 20;    // å¯å˜ç»‘å®š
y = 30;            // å¯ä»¥ä¿®æ”¹
```

## 2. MUTABILITYï¼ˆå¯å˜æ€§ï¼‰

Rustä¸­çš„ç»‘å®š**é»˜è®¤æ˜¯ä¸å¯å˜çš„**ï¼Œè¿™æ˜¯Rustå®‰å…¨æ€§è®¾è®¡çš„æ ¸å¿ƒç‰¹æ€§ï¼š

rust

```rust
let x = 5;
x = 6;  // âŒ é”™è¯¯ï¼xæ˜¯ä¸å¯å˜çš„

let mut y = 5;
y = 6;  // âœ… æ­£ç¡®ï¼yæ˜¯å¯å˜çš„
```

**è®¾è®¡ç†å¿µï¼š**

- ä¸å¯å˜æ€§æ˜¯é»˜è®¤çš„ï¼Œé¼“åŠ±æ›´å®‰å…¨çš„ä»£ç 
- éœ€è¦å¯å˜æ€§æ—¶å¿…é¡»æ˜¾å¼å£°æ˜`mut`
- è¿™å¸®åŠ©é˜²æ­¢æ„å¤–ä¿®æ”¹æ•°æ®
- ä½¿ä»£ç æ›´å®¹æ˜“æ¨ç†å’Œç»´æŠ¤

## 3. SHADOWINGï¼ˆé®è”½ï¼‰

Shadowingå…è®¸ä½ ç”¨ç›¸åŒçš„åç§°å£°æ˜æ–°çš„ç»‘å®šï¼Œ**é®è”½**ä¹‹å‰çš„ç»‘å®šï¼š

rust

```rust
let x = 5;
let x = x + 1;     // åˆ›å»ºæ–°çš„xï¼Œé®è”½äº†æ—§çš„x
let x = x * 2;     // å†æ¬¡é®è”½
println!("{}", x); // è¾“å‡º: 12
```

**Shadowing vs å¯å˜æ€§çš„åŒºåˆ«ï¼š**

rust

```rust
// Shadowing - å¯ä»¥æ”¹å˜ç±»å‹
let spaces = "   ";
let spaces = spaces.len();  // âœ… ä»&strå˜ä¸ºusize

// å¯å˜æ€§ - ä¸èƒ½æ”¹å˜ç±»å‹
let mut spaces = "   ";
spaces = spaces.len();      // âŒ é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
```

**Shadowingçš„ä¼˜åŠ¿ï¼š**

- å¯ä»¥æ”¹å˜å€¼çš„ç±»å‹
- å¯ä»¥é‡ç”¨å˜é‡å
- æ¯æ¬¡shadowingéƒ½åˆ›å»ºæ–°çš„ä¸å¯å˜ç»‘å®š
- åœ¨ä¸åŒä½œç”¨åŸŸä¸­å¯ä»¥æœ‰ä¸åŒçš„å«ä¹‰

## 4. ASIDE: CONSTANTSï¼ˆè¡¥å……ï¼šå¸¸é‡ï¼‰

å¸¸é‡ä¸ä¸å¯å˜ç»‘å®šæœ‰é‡è¦åŒºåˆ«ï¼š

rust

```rust
const MAX_POINTS: u32 = 100_000;
```

**å¸¸é‡çš„ç‰¹ç‚¹ï¼š**

- ä½¿ç”¨`const`å…³é”®å­—å£°æ˜
- **å¿…é¡»æ ‡æ³¨ç±»å‹**
- å¿…é¡»åœ¨ç¼–è¯‘æ—¶å°±èƒ½ç¡®å®šå€¼
- å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
- å‘½åçº¦å®šï¼šå…¨å¤§å†™å­—æ¯ï¼Œä¸‹åˆ’çº¿åˆ†éš”

---

**æ€»ç»“ï¼š** è¿™å››ä¸ªæ¦‚å¿µå…±åŒæ„æˆäº†Rustå˜é‡ç³»ç»Ÿçš„åŸºç¡€ã€‚ç»‘å®šå¼ºè°ƒæ‰€æœ‰æƒï¼Œé»˜è®¤ä¸å¯å˜æ€§ä¿è¯å®‰å…¨ï¼Œshadowingæä¾›çµæ´»æ€§ï¼Œè€Œå¸¸é‡æä¾›çœŸæ­£çš„ç¼–è¯‘æ—¶å¸¸é‡ã€‚è¿™äº›è®¾è®¡ä½¿Rustæ—¢å®‰å…¨åˆçµæ´»ã€‚






## 1. INTEGER TYPESï¼ˆæ•´æ•°ç±»å‹ - FIXED, ARCHï¼‰

Rustæä¾›äº†å¤šç§æ•´æ•°ç±»å‹ï¼Œåˆ†ä¸º**å›ºå®šå¤§å°ç±»å‹**å’Œ**æ¶æ„ç›¸å…³ç±»å‹**ã€‚

### å›ºå®šå¤§å°æ•´æ•°ç±»å‹ï¼ˆFixed-sizeï¼‰

**æœ‰ç¬¦å·æ•´æ•°ï¼ˆsignedï¼‰ï¼š** å¯ä»¥è¡¨ç¤ºæ­£æ•°ã€è´Ÿæ•°å’Œé›¶

|ç±»å‹|å¤§å°|èŒƒå›´|
|---|---|---|
|`i8`|8ä½|-128 åˆ° 127|
|`i16`|16ä½|-32,768 åˆ° 32,767|
|`i32`|32ä½|-2,147,483,648 åˆ° 2,147,483,647|
|`i64`|64ä½|-9,223,372,036,854,775,808 åˆ° 9,223,372,036,854,775,807|
|`i128`|128ä½|éå¸¸å¤§çš„èŒƒå›´|

**æ— ç¬¦å·æ•´æ•°ï¼ˆunsignedï¼‰ï¼š** åªèƒ½è¡¨ç¤ºéè´Ÿæ•°

|ç±»å‹|å¤§å°|èŒƒå›´|
|---|---|---|
|`u8`|8ä½|0 åˆ° 255|
|`u16`|16ä½|0 åˆ° 65,535|
|`u32`|32ä½|0 åˆ° 4,294,967,295|
|`u64`|64ä½|0 åˆ° 18,446,744,073,709,551,615|
|`u128`|128ä½|éå¸¸å¤§çš„èŒƒå›´|

**ç¤ºä¾‹ä»£ç ï¼š**

rust

```rust
// æ•´æ•°å­—é¢é‡å¯ä»¥ä½¿ç”¨ç±»å‹åç¼€
let x = 42u8;               // u8ç±»å‹
let y = 100i32;             // i32ç±»å‹
```

### æ¶æ„ç›¸å…³ç±»å‹ï¼ˆArchitecture-dependentï¼‰

|ç±»å‹|è¯´æ˜|
|---|---|
|`isize`|æœ‰ç¬¦å·ï¼Œå¤§å°å–å†³äºCPUæ¶æ„ï¼ˆ32ä½ç³»ç»Ÿä¸Šæ˜¯32ä½ï¼Œ64ä½ç³»ç»Ÿä¸Šæ˜¯64ä½ï¼‰|
|`usize`|æ— ç¬¦å·ï¼Œå¤§å°å–å†³äºCPUæ¶æ„|

æŒ‡é’ˆè¿ç®—å’Œå†…å­˜åœ°å€ä½¿ç”¨isize/usize



---

## 2. FLOATING POINT TYPESï¼ˆæµ®ç‚¹æ•°ç±»å‹ï¼‰

Rustæœ‰ä¸¤ç§æµ®ç‚¹æ•°ç±»å‹ï¼Œéƒ½æ˜¯**æœ‰ç¬¦å·**çš„ï¼š

|ç±»å‹|å¤§å°|ç²¾åº¦|
|---|---|---|
|`f32`|32ä½|å•ç²¾åº¦|
|`f64`|64ä½|åŒç²¾åº¦ï¼ˆé»˜è®¤ï¼‰|


**æ³¨æ„äº‹é¡¹ï¼š**

rust

```rust
// æµ®ç‚¹æ•°æ¯”è¾ƒè¦å°å¿ƒ
let a = 0.1 + 0.2;
let b = 0.3;
// a == b å¯èƒ½æ˜¯falseï¼Œå› ä¸ºæµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜

// æ¨èä½¿ç”¨epsilonæ¯”è¾ƒ
let epsilon = 0.00001;
if (a - b).abs() < epsilon {
    println!("è¿‘ä¼¼ç›¸ç­‰");
}
```

---

## 3. BOOLEANï¼ˆå¸ƒå°”ç±»å‹ï¼‰

å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼š`true` å’Œ `false`ï¼Œå ç”¨**1ä¸ªå­—èŠ‚**ã€‚

rust

```rust
let t: bool = true;
let f: bool = false;

// å¸¸ç”¨äºæ¡ä»¶åˆ¤æ–­
if t {
    println!("è¿™æ˜¯çœŸçš„ï¼");
}

// å¸ƒå°”è¿ç®—
let and = true && false;    // false
let or = true || false;     // true
let not = !true;            // false

// æ¯”è¾ƒè¿ç®—è¿”å›å¸ƒå°”å€¼
let greater = 5 > 3;        // true
let equal = 5 == 5;         // true
```

---

## 4. CHARACTERï¼ˆå­—ç¬¦ç±»å‹ï¼‰

Rustçš„`char`ç±»å‹ä»£è¡¨ä¸€ä¸ª**Unicodeæ ‡é‡å€¼**ï¼Œå ç”¨**4ä¸ªå­—èŠ‚**ã€‚

rust

```rust
let c: char = 'z';
let z: char = 'â„¤';
let heart_eyed_cat: char = 'ğŸ˜»';
let chinese: char = 'ä¸­';

// æ³¨æ„ï¼šcharä½¿ç”¨å•å¼•å·ï¼Œå­—ç¬¦ä¸²ä½¿ç”¨åŒå¼•å·
let character = 'A';    // char
let string = "A";       // &str
```



---

## ç±»å‹æ¨æ–­ä¸æ˜¾å¼æ ‡æ³¨

Rustæœ‰å¼ºå¤§çš„ç±»å‹æ¨æ–­èƒ½åŠ›ï¼š

rust

```rust
// ç±»å‹æ¨æ–­
let x = 5;          // ç¼–è¯‘å™¨æ¨æ–­ä¸ºi32
let y = 2.0;        // ç¼–è¯‘å™¨æ¨æ–­ä¸ºf64

// æ˜¾å¼ç±»å‹æ ‡æ³¨
let a: i64 = 5;
let b: f32 = 2.0;
let c: bool = true;
let d: char = 'x';

// ä¸Šä¸‹æ–‡å¸®åŠ©æ¨æ–­
let mut vec = Vec::new();
vec.push(1);        // ç¼–è¯‘å™¨æ¨æ–­vecæ˜¯Vec<i32>
```








## 1. TUPLES, ARRAYSï¼ˆå…ƒç»„å’Œæ•°ç»„ï¼‰

### å…ƒç»„ï¼ˆTuplesï¼‰

å…ƒç»„æ˜¯å°†**å¤šä¸ªä¸åŒç±»å‹**çš„å€¼ç»„åˆæˆä¸€ä¸ªå¤åˆç±»å‹çš„æ–¹å¼ã€‚

**åŸºæœ¬è¯­æ³•ï¼š**

rust

```rust
// åˆ›å»ºå…ƒç»„
let tup: (i32, f64, u8) = (500, 6.4, 1);

// è§£æ„å…ƒç»„
let (x, y, z) = tup;
println!("y çš„å€¼æ˜¯: {}", y);  // è¾“å‡º: 6.4

// é€šè¿‡ç´¢å¼•è®¿é—®
let five_hundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;
```

**å…ƒç»„çš„ç‰¹ç‚¹ï¼š**

rust

```rust
// å›ºå®šé•¿åº¦ï¼Œåˆ›å»ºåä¸èƒ½æ”¹å˜å¤§å°
let tuple = (1, 2, 3);

// å¯ä»¥åŒ…å«ä¸åŒç±»å‹
let mixed = (42, "hello", 3.14, true);

// å¯ä»¥åµŒå¥—
let nested = ((1, 2), (3, 4));

// ç©ºå…ƒç»„ç§°ä¸ºunitï¼Œå†™ä½œ ()
let unit = ();
```

**å®é™…åº”ç”¨ï¼š**

rust

```rust
// å‡½æ•°è¿”å›å¤šä¸ªå€¼
fn calculate(x: i32) -> (i32, i32, i32) {
    (x + 1, x * 2, x * x)
}

fn main() {
    let (add, mul, square) = calculate(5);
    println!("åŠ 1: {}, ä¹˜2: {}, å¹³æ–¹: {}", add, mul, square);
}

// äº¤æ¢ä¸¤ä¸ªå€¼
let mut a = 1;
let mut b = 2;
(a, b) = (b, a);  // äº¤æ¢
```

### æ•°ç»„ï¼ˆArraysï¼‰

æ•°ç»„æ˜¯**å›ºå®šé•¿åº¦**ã€**ç›¸åŒç±»å‹**å…ƒç´ çš„é›†åˆã€‚

**åŸºæœ¬è¯­æ³•ï¼š**

rust

```rust
// åˆ›å»ºæ•°ç»„
let arr: [i32; 5] = [1, 2, 3, 4, 5];

// ç®€å†™ï¼šæ‰€æœ‰å…ƒç´ ç›¸åŒ
let arr = [3; 5];  // ç­‰åŒäº [3, 3, 3, 3, 3]

// è®¿é—®å…ƒç´ 
let first = arr[0];
let second = arr[1];
```

**æ•°ç»„çš„ç‰¹ç‚¹ï¼š**

rust

```rust
// å›ºå®šé•¿åº¦ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
let months = ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", 
              "å…­æœˆ", "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", 
              "åä¸€æœˆ", "åäºŒæœˆ"];

// ç±»å‹æ ‡æ³¨ï¼š[ç±»å‹; é•¿åº¦]
let numbers: [i32; 3] = [1, 2, 3];

// è·å–é•¿åº¦
let len = numbers.len();  // 3
```

**æ•°ç»„è¶Šç•Œæ£€æŸ¥ï¼š**

rust

```rust
let arr = [1, 2, 3, 4, 5];

// è¿è¡Œæ—¶ä¼španic
// let element = arr[10];  // ç´¢å¼•è¶Šç•Œï¼

// å®‰å…¨è®¿é—®
if let Some(value) = arr.get(2) {
    println!("å€¼æ˜¯: {}", value);
}
```

**æ•°ç»„éå†ï¼š**

rust

```rust
let arr = [10, 20, 30, 40, 50];

// æ–¹æ³•1ï¼šforå¾ªç¯
for element in arr {
    println!("å€¼: {}", element);
}

// æ–¹æ³•2ï¼šå¸¦ç´¢å¼•
for (index, value) in arr.iter().enumerate() {
    println!("ç´¢å¼• {}: å€¼ {}", index, value);
}
```

---

## 2. STRUCTS, ENUMSï¼ˆç»“æ„ä½“å’Œæšä¸¾ï¼‰

### ç»“æ„ä½“ï¼ˆStructsï¼‰

ç»“æ„ä½“ç”¨äºåˆ›å»º**è‡ªå®šä¹‰æ•°æ®ç±»å‹**ï¼Œå°†ç›¸å…³æ•°æ®ç»„åˆåœ¨ä¸€èµ·ã€‚

**ä¸‰ç§ç»“æ„ä½“ç±»å‹ï¼š**

**1. å‘½åå­—æ®µç»“æ„ä½“ï¼š**

rust

```rust
// å®šä¹‰ç»“æ„ä½“
struct User {
    username: String,
    email: String,
    age: u32,
    active: bool,
}

// åˆ›å»ºå®ä¾‹
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("å¼ ä¸‰"),
    age: 25,
    active: true,
};

// è®¿é—®å­—æ®µ
println!("ç”¨æˆ·å: {}", user1.username);

// å¯å˜å®ä¾‹
let mut user2 = User {
    email: String::from("another@example.com"),
    username: String::from("æå››"),
    age: 30,
    active: true,
};
user2.age = 31;  // ä¿®æ”¹å­—æ®µ
```

**2. å…ƒç»„ç»“æ„ä½“ï¼š**

rust

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// è®¿é—®å­—æ®µ
println!("çº¢è‰²å€¼: {}", black.0);
```

**3. å•å…ƒç»“æ„ä½“ï¼ˆæ— å­—æ®µï¼‰ï¼š**

rust

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;
```

**ç»“æ„ä½“æ–¹æ³•ï¼š**

rust

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•ï¼ˆéœ€è¦selfï¼‰
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // å…³è”å‡½æ•°ï¼ˆä¸éœ€è¦selfï¼‰
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    println!("é¢ç§¯: {}", rect.area());
    
    let sq = Rectangle::square(20);
}
```

### æšä¸¾ï¼ˆEnumsï¼‰

æšä¸¾å…è®¸ä½ å®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œå®ƒçš„å€¼å¯ä»¥æ˜¯**å‡ ä¸ªå˜ä½“ä¹‹ä¸€**ã€‚

**åŸºæœ¬æšä¸¾ï¼š**

rust

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

let direction = Direction::North;
```

**å¸¦æ•°æ®çš„æšä¸¾ï¼š**

rust

```rust
enum Message {
    Quit,                       // æ— æ•°æ®
    Move { x: i32, y: i32 },   // å‘½åå­—æ®µ
    Write(String),              // å•ä¸ªå€¼
    ChangeColor(i32, i32, i32), // å…ƒç»„
}

let msg1 = Message::Quit;
let msg2 = Message::Move { x: 10, y: 20 };
let msg3 = Message::Write(String::from("hello"));
let msg4 = Message::ChangeColor(255, 0, 0);
```

**Optionæšä¸¾ï¼ˆæœ€é‡è¦çš„æšä¸¾ä¹‹ä¸€ï¼‰ï¼š**

rust

```rust
enum Option<T> {
    Some(T),
    None,
}

// ä½¿ç”¨Optionå¤„ç†å¯èƒ½ä¸å­˜åœ¨çš„å€¼
let some_number = Some(5);
let some_string = Some("å­—ç¬¦ä¸²");
let absent_number: Option<i32> = None;

// ä½¿ç”¨matchå¤„ç†
match some_number {
    Some(value) => println!("å€¼æ˜¯: {}", value),
    None => println!("æ²¡æœ‰å€¼"),
}
```

**Resultæšä¸¾ï¼ˆé”™è¯¯å¤„ç†ï¼‰ï¼š**

rust

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("é™¤æ•°ä¸èƒ½ä¸ºé›¶"))
    } else {
        Ok(a / b)
    }
}

match divide(10, 2) {
    Ok(result) => println!("ç»“æœ: {}", result),
    Err(err) => println!("é”™è¯¯: {}", err),
}
```

**æšä¸¾æ–¹æ³•ï¼š**

rust

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

impl TrafficLight {
    fn time(&self) -> u32 {
        match self {
            TrafficLight::Red => 60,
            TrafficLight::Yellow => 3,
            TrafficLight::Green => 90,
        }
    }
}

let light = TrafficLight::Red;
println!("æ—¶é•¿: {} ç§’", light.time());
```

---

## 3. ASIDE: PERVASIVE MUTABILITYï¼ˆè¡¥å……ï¼šæ™®éå¯å˜æ€§ï¼‰

**å†…éƒ¨å¯å˜æ€§ï¼ˆInterior Mutabilityï¼‰ï¼š**

åœ¨Rustä¸­ï¼Œå³ä½¿å˜é‡æœ¬èº«ä¸å¯å˜ï¼ŒæŸäº›ç±»å‹ä¹Ÿå…è®¸ä¿®æ”¹å†…éƒ¨å€¼ã€‚

**Cell å’Œ RefCellï¼š**

rust

```rust
use std::cell::Cell;
use std::cell::RefCell;

// Cellï¼šç”¨äºCopyç±»å‹
let c = Cell::new(5);
c.set(10);
println!("{}", c.get());

// RefCellï¼šç”¨äºéCopyç±»å‹
let s = RefCell::new(String::from("hello"));
s.borrow_mut().push_str(" world");
println!("{}", s.borrow());
```

**Rc å’Œ Arcï¼ˆå…±äº«æ‰€æœ‰æƒï¼‰ï¼š**

rust

```rust
use std::rc::Rc;

let a = Rc::new(5);
let b = Rc::clone(&a);
let c = Rc::clone(&a);

println!("å¼•ç”¨è®¡æ•°: {}", Rc::strong_count(&a));  // 3
```

**ç»“æ„ä½“ä¸­çš„å¯å˜æ€§ï¼š**

rust

```rust
struct Config {
    data: RefCell<String>,
}

let config = Config {
    data: RefCell::new(String::from("åˆå§‹å€¼")),
};

// å³ä½¿configä¸å¯å˜ï¼Œä¹Ÿèƒ½ä¿®æ”¹å†…éƒ¨æ•°æ®
*config.data.borrow_mut() = String::from("æ–°å€¼");
```

---

## 4. ASIDE: UNITï¼ˆè¡¥å……ï¼šå•å…ƒç±»å‹ï¼‰

**å•å…ƒç±»å‹ `()`ï¼š**

å•å…ƒç±»å‹æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ï¼Œåªæœ‰ä¸€ä¸ªå€¼ï¼Œä¹Ÿå†™ä½œ `()`ã€‚

**ç”¨é€”ï¼š**

rust

```rust
// 1. æ— è¿”å›å€¼çš„å‡½æ•°
fn do_something() -> () {
    println!("åšäº›äº‹æƒ…");
    // éšå¼è¿”å› ()
}

// ç­‰åŒäº
fn do_something() {
    println!("åšäº›äº‹æƒ…");
}

// 2. åœ¨æ³›å‹ä¸­ä½œä¸ºå ä½ç¬¦
let empty_tuple = ();

// 3. è¡¨ç¤º"æ— æ„ä¹‰"çš„å€¼
let result: Result<(), String> = Ok(());

// 4. æ•°ç»„å’Œå‘é‡
let empty_array: [(); 0] = [];
```

**å®é™…åº”ç”¨ï¼š**

rust

```rust
// å½“å‡½æ•°æ‰§è¡Œå‰¯ä½œç”¨ä½†ä¸è¿”å›å€¼æ—¶
fn save_to_file(content: &str) -> Result<(), std::io::Error> {
    std::fs::write("file.txt", content)?;
    Ok(())  // æˆåŠŸä½†æ— è¿”å›å€¼
}

// matchè¡¨è¾¾å¼çš„æŸäº›åˆ†æ”¯
fn process(option: Option<i32>) {
    match option {
        Some(value) => println!("å€¼: {}", value),
        None => (),  // ä»€ä¹ˆéƒ½ä¸åš
    }
}
```

---

## ç»¼åˆç¤ºä¾‹

rust

```rust
// ç»“åˆå¤šç§å¤åˆç±»å‹
struct Point {
    x: f64,
    y: f64,
}

enum Shape {
    Circle { center: Point, radius: f64 },
    Rectangle { top_left: Point, bottom_right: Point },
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius, .. } => std::f64::consts::PI * radius * radius,
            Shape::Rectangle { top_left, bottom_right } => {
                let width = (bottom_right.x - top_left.x).abs();
                let height = (bottom_right.y - top_left.y).abs();
                width * height
            }
        }
    }
}

fn main() {
    let circle = Shape::Circle {
        center: Point { x: 0.0, y: 0.0 },
        radius: 5.0,
    };
    
    println!("åœ†çš„é¢ç§¯: {}", circle.area());
}
```