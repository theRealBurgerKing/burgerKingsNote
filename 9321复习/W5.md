Web server part 2


==很重要==
## Architectural Constraints of REST
1.client-server
2.uniform interface
3.statelessness
4.caching
5.layered system

# 统一接口 - 链接资源（Linked Resources）- 笔记

## 一、表现形式是超媒体

### 核心概念

**表现形式是超媒体：资源（数据本身）+ 链接到其他资源**


## 二、REST 中的连接性

### 三种服务级别

```
连接性程度：
低 ← ─────────────────────── → 高

a          b          c
```

**示意图说明**：

- **a**：少量独立的盒子
- **b**：一些盒子有连接
- **c**：盒子之间密集连接，形成网络

---

### 三种服务对比

**所有三种服务都暴露相同的功能，但可用性向右递增**

#### Service A（服务 A）

**特点**：

- 典型的远程函数调用风格服务
- 通过单一 URI 暴露所有内容
- **既不可寻址，也不连接**

**问题**：

```
所有功能 → 单一入口点
         → 无法直接访问特定资源
         → 无法发现相关资源
```

**类比**：

- 像一个黑盒 API
- 必须知道确切的函数调用
- 没有探索性

---

#### Service B（服务 B）

**特点**：

- **可寻址但不连接**
- 资源之间没有关系指示
- 混合风格

**优势**：

- ✅ 每个资源有独立的 URI
- ✅ 可以直接访问特定资源

**劣势**：

- ❌ 资源之间没有链接
- ❌ 无法发现相关资源
- ❌ 需要外部文档说明关系

**例子**：

```
/users/123       ← 可以直接访问
/orders/456      ← 可以直接访问
但不知道这个用户有哪些订单
```

---

#### Service C（服务 C）

**特点**：

- **可寻址且连接良好**
- 资源之间以有意义的方式链接
- **完全 RESTful 的服务**

**优势**：

- ✅ 每个资源有独立的 URI
- ✅ 资源包含到相关资源的链接
- ✅ 可发现性强
- ✅ 自文档化

**例子**：

```
GET /users/123
{
  "id": 123,
  "name": "Alice",
  "links": {
    "orders": "/users/123/orders",
    "profile": "/users/123/profile",
    "friends": "/users/123/friends"
  }
}
```



# 无状态性（Statelessness）- REST 约束 3 - 笔记

## 一、无状态性定义

**REST API 必须是无状态的**

- 所有来自客户端的调用都是独立的
- 每个 HTTP 请求都在完全隔离的环境中发生

---

## 二、无状态的好处

✅ 可扩展（Scalable）  
✅ 易于缓存（Easy to cache）  
✅ 可寻址的 URI 可以被收藏（例如：搜索结果的第 10 页）

---

## 三、HTTP 会话问题

**HTTP 本质上是无状态的，但我们需要打破它来构建应用**

### 最常见方式：HTTP 会话

**工作原理**：

1. 用户首次访问网站，获得唯一会话 ID
2. 示例：`http://www.example.com/forum?PHPSESSIONID=27314962133`
3. 会话 ID 是服务器上数据结构的键
4. 包含用户操作记录
5. 所有交互都依赖这个键

---

## 四、什么才算"状态"？

### 场景：类似 Flickr 的网站

添加照片、重命名照片、分享照片等

"无状态"在这里意味着什么？

---

## 五、关键概念

### **分离客户端应用状态和 RESTful 资源状态**

#### 应用状态（Application State）

- 可能因客户端和请求而异的数据
- 每个客户端不同

#### 资源状态（Resource State）

- 可以由服务器集中管理的数据
- 对每个客户端都相同

---

## 六、REST 的要求

✅ **资源状态存储在服务器上** ❌ **客户端应用状态应该远离服务器**





这个PPT讲解的是REST架构中的**无状态性（Statelessness）**原则。让我详细解释一下：

## 核心概念

==**无状态性在REST中的含义**：从服务器的角度来看，客户端应用的状态信息不应该保存在服务器端。==

## 对客户端应用的意义

PPT列出了两个关键点：

1. **每个REST请求都应该是完全自描述的**（be totally self-descriptive）
    - 这意味着每个请求必须包含服务器处理该请求所需的所有信息
    - 服务器不应该依赖之前请求中的任何信息
2. **客户端需要在每次请求时传输状态信息给服务器**
    - 状态信息通过以下三个部分传输：
        - HTTP请求（URL和参数）
        - HTTP请求头（例如accept类型）
        - 请求体内容（Body Content）

## RESTful服务的要求

PPT强调：RESTful服务要求应用状态保持在客户端。服务器不代表客户端保存应用状态。

## 与OAuth的关系

最后提出了一个思考问题：**OAuth与REST的无状态性是否冲突？**

这是一个有趣的问题，因为OAuth在认证流程中确实需要维护一些状态（比如授权码、token等），但这通常通过token机制来实现，token本身携带了认证信息，所以在某种程度上仍然符合无状态原则。

## 总结

这个PPT的核心思想是：在REST架构中，服务器不应该记住客户端的状态，每次请求都应该是独立且完整的，所有必要信息都由客户端提供。




# Cache
## 第一页：缓存的基本概念

### 核心要求

响应必须被标记为"可缓存"或"不可缓存"

### 缓存的好处

**良好管理的缓存可以部分或完全消除某些客户端-服务器交互，从而提高可扩展性和性能。**

### 无状态性与缓存的关系

**无状态性的影响**：

- ✅ **优点**：保持交互协议更简单
- ⚠️ **缺点**：交互可能变得"更啰嗦"（chattier）
    - 因为每次请求都要携带完整信息，数据传输量增加

### RESTful API的扩展要求

为了扩展，RESTful API必须**工作害羞**（work-shy）：

- 只在需要时生成数据流量
- 其他时间使用缓存
就是说尽量使用缓存来提高效率


### 服务器-客户端协作机制

**这需要服务器和客户端的协作**，通过以下方式实现：

1. **客户端提供守护子句**（guard clauses）
    - 让服务器能够轻松判断是否有工作需要完成
2. **使用HTTP缓存头**：
    - `If-Modified-Since`：如果自某时间后修改过
    - `Last-Modified`：最后修改时间
    - `If-None-Match`：配合ETag使用
    - `ETag`：实体标签

---

## 第二页：定义最优缓存控制策略

这是一个**决策流程图**，帮助确定如何设置Cache-Control策略：

### 决策流程

1. **响应可重用吗？**（Reusable response?）
    - ❌ **No** → 设置 `no-store`
    - ✅ **Yes** → 继续下一步
2. **每次都需要重新验证吗？**（Revalidate each time?）
    - ✅ **Yes** → 设置 `no-cache`
    - ❌ **No** → 继续下一步
3. **可被中间缓存缓存吗？**（Cacheable by intermediate caches?）
    - ❌ **No** → 设置 `private`（仅浏览器缓存）
    - ✅ **Yes** → 设置 `public`（可被代理、CDN等缓存）
4. **最大缓存生命周期？**（Maximum cache lifetime?）
    - 设置 `max-age=...`（秒数）
5. **添加ETag头**
    - 用于缓存验证




## Cache-Control 头的组合

### 1. `Cache-Control: no-store` - 完全不缓存

**含义**：禁止任何缓存存储这个响应

**场景示例**：

http

```http
GET /api/bank/account/balance
Response:
Cache-Control: no-store
{
  "balance": 10000,
  "timestamp": "2024-11-30T10:30:00Z"
}
```

**实际应用**：

- 银行账户余额
- 敏感的个人信息（身份证号、密码）
- 实时股票价格
- 医疗记录

**为什么？** 这些数据非常敏感或变化极快，绝对不能被缓存，每次都必须从服务器获取最新数据。

---

### 2. `Cache-Control: no-cache` - 必须验证

**含义**：可以缓存，但使用前必须向服务器验证是否仍然有效

**场景示例**：

http

````http
GET /api/news/latest
Response:
Cache-Control: no-cache
ETag: "v1.0"
{
  "headline": "Breaking News..."
}
```

**工作流程**：
```
第一次请求：
客户端 → 服务器：GET /api/news/latest
服务器 → 客户端：200 OK + 完整数据 + ETag

第二次请求：
客户端 → 服务器：GET /api/news/latest + If-None-Match: "v1.0"
服务器 → 客户端：304 Not Modified（如果没变）或 200 OK + 新数据（如果变了）
````

**实际应用**：

- 新闻文章（可能随时更新）
- 用户资料页面
- 配置文件

**为什么？** 数据可能会变，但不是每秒都变。通过验证，如果没变就不传输数据（节省带宽），如果变了就获取新数据（保证准确性）。

---

### 3. `Cache-Control: private, max-age=3600` - 私有缓存1小时

**含义**：

- `private`：只能被用户的浏览器缓存，不能被CDN、代理等中间缓存
- `max-age=3600`：缓存有效期3600秒（1小时）

**场景示例**：

http

````http
GET /api/user/profile
Response:
Cache-Control: private, max-age=3600
{
  "name": "张三",
  "email": "zhangsan@example.com",
  "preferences": {...}
}
```

**时间线**：
```
10:00 - 第一次请求，从服务器获取数据
10:30 - 再次访问个人资料，直接从浏览器缓存读取（不发请求）
10:59 - 访问个人资料，仍从缓存读取
11:01 - 缓存过期，重新向服务器请求
````

**实际应用**：

- 用户个人资料
- 用户的购物车
- 个性化推荐
- 登录后的仪表板

**为什么用 `private`？** 因为这是个人数据，不应该被公共CDN缓存，否则可能泄露给其他用户。

---

### 4. `Cache-Control: public, max-age=86400` - 公共缓存1天

**含义**：

- `public`：可以被任何缓存（浏览器、CDN、代理）缓存
- `max-age=86400`：缓存有效期86400秒（24小时）

**场景示例**：

http

````http
GET /api/products/12345
Response:
Cache-Control: public, max-age=86400
{
  "id": 12345,
  "name": "iPhone 15",
  "description": "最新款手机",
  "image": "https://cdn.example.com/iphone15.jpg"
}
```

**缓存层级**：
```
用户 → 浏览器缓存 → CDN缓存 → 代理服务器缓存 → 源服务器

第一个用户请求：源服务器返回，各层都缓存
第二个用户请求：直接从CDN返回（不到达源服务器）
````

**实际应用**：

- 产品信息（不常变）
- 静态文章
- 公共API文档
- Logo、图标等静态资源

**为什么用 `public`？** 这些是公开数据，让CDN缓存可以减轻服务器压力，加快全球各地用户的访问速度。

---

## ETag 配合使用的完整示例

让我用一个**博客文章**的例子来说明：

### 第一次访问文章

**客户端请求**：

http

```http
GET /api/articles/123 HTTP/1.1
Host: blog.example.com
```

**服务器响应**：

http

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Content-Type: application/json

{
  "title": "REST API 最佳实践",
  "content": "...",
  "updated_at": "2024-11-30T09:00:00Z"
}
```

**发生了什么？**

1. 服务器返回文章内容
2. 同时返回 ETag（内容的"指纹"，通常是内容的哈希值）
3. 设置缓存1小时

---

### 30分钟后再次访问（缓存未过期）

**客户端行为**：

- 直接从本地缓存读取
- **不发送任何请求到服务器**
- 瞬间显示内容

---

### 1小时后再次访问（缓存已过期）

**客户端请求**：

http

```http
GET /api/articles/123 HTTP/1.1
Host: blog.example.com
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

**注意**：客户端带上了之前保存的 ETag

#### 情况A：文章没有修改

**服务器响应**：

http

```http
HTTP/1.1 304 Not Modified
Cache-Control: public, max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

**发生了什么？**

1. 服务器检查文章的当前 ETag
2. 发现和客户端的 ETag 一样（内容未变）
3. 返回 `304 Not Modified`（**没有 body，节省带宽**）
4. 客户端继续使用本地缓存的内容
5. 缓存刷新，再有效1小时

**流量节省**：

- 原本可能需要传输 50KB 的文章内容
- 现在只传输了几百字节的响应头

---

#### 情况B：文章已修改

**服务器响应**：

http

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=3600
ETag: "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b"  ← 新的 ETag
Content-Type: application/json

{
  "title": "REST API 最佳实践（更新版）",
  "content": "...新内容...",
  "updated_at": "2024-11-30T10:30:00Z"
}
```

**发生了什么？**

1. 服务器检查发现 ETag 不匹配（内容已修改）
2. 返回 `200 OK` 和完整的新内容
3. 返回新的 ETag
4. 客户端更新缓存







这两页PPT介绍了REST架构的第五个约束和REST成熟度模型。让我详细解释：

---

## 第一页：分层系统（Layered System）

### 架构图解析

这个图展示了典型的REST分层架构：

```
客户端 ↔ API端点 ↔ 负载均衡 ↔ 认证服务器
                              ↔ 应用逻辑 ↔ 数据存储服务器
                              ↔ 外部逻辑
```

### 核心概念

**关键原则**：

> 客户端通常无法分辨它是直接连接到最终服务器，还是连接到中间的某个中介。

这意味着什么？

**客户端视角**：

```
客户端看到的：
我 → API端点 (https://api.example.com)

实际发生的（客户端不知道）：
我 → CDN → 负载均衡器 → 防火墙 → API网关 → 认证层 → 应用服务器 → 数据库
```

### 为什么要分层？

**解耦的好处**：

> 同样，解耦允许架构中的组件独立演进

### 各层的职责

|层级|职责|例子|
|---|---|---|
|**API端点**|统一入口|api.example.com|
|**负载均衡**|分发请求|Nginx, AWS ELB|
|**认证服务器**|验证身份|OAuth, JWT验证|
|**应用逻辑**|业务处理|Node.js, Java应用|
|**数据存储**|持久化数据|MySQL, MongoDB|
|**外部逻辑**|第三方服务|支付网关, 邮件服务|

---

## 第二页：Richardson 成熟度模型

这是由Leonard Richardson提出的模型，用于**衡量API的RESTful程度**。

### Level 0: POX沼泽（The Swamp of POX）

**POX = Plain Old XML**（也适用于JSON）

**特征**：

- 只有一个URI端点
- 所有操作细节都包含在请求体中

**示例**：

http

```http
POST /api/endpoint HTTP/1.1

{
  "action": "getUser",
  "userId": 123
}
```

http

```http
POST /api/endpoint HTTP/1.1

{
  "action": "createUser",
  "name": "张三",
  "email": "zhangsan@example.com"
}
```

**问题**：

- ❌ 无法利用HTTP缓存
- ❌ 无法利用HTTP方法语义
- ❌ 所有操作看起来都一样
- ❌ 类似于RPC调用

**现实例子**：很多老旧的SOAP服务

---

### Level 1: 资源（Resources）

**特征**：

- 为每个资源暴露单独的URI
- 但请求中可能仍包含操作细节

**示例**：

http

```http
POST /api/users HTTP/1.1
{
  "action": "get",
  "id": 123
}
```

http

```http
POST /api/products HTTP/1.1
{
  "action": "list",
  "category": "electronics"
}
```

**改进**：

- ✅ 有了资源的概念
- ✅ URI更有意义
- ❌ 但仍然在请求体中指定操作

---

### Level 2: HTTP动词（HTTP Verbs）

**特征**：

- 使用标准HTTP方法
- 使用HTTP状态码
- 资源URI + HTTP方法组合

**示例**：

http

```http
GET /api/users/123 HTTP/1.1
→ 200 OK

POST /api/users HTTP/1.1
{
  "name": "张三",
  "email": "zhangsan@example.com"
}
→ 201 Created

PUT /api/users/123 HTTP/1.1
{
  "name": "张三",
  "email": "new@example.com"
}
→ 200 OK

DELETE /api/users/123 HTTP/1.1
→ 204 No Content
```

**改进**：

- ✅ 使用HTTP方法表达操作意图
- ✅ 使用HTTP状态码表达结果
- ✅ 可以利用HTTP缓存（GET请求）
- ✅ 符合HTTP语义

**大多数"RESTful API"都在这个级别**

---

### Level 3: HATEOAS（超媒体控制）

**HATEOAS = Hypermedia As The Engine Of Application State**

**特征**：

- 响应中包含链接
- 客户端通过链接导航
- 自文档化

**示例**：

http

```http
GET /api/users/123 HTTP/1.1
```

**响应**：

json

```json
{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "links": [
    {
      "rel": "self",
      "href": "/api/users/123",
      "method": "GET"
    },
    {
      "rel": "update",
      "href": "/api/users/123",
      "method": "PUT"
    },
    {
      "rel": "delete",
      "href": "/api/users/123",
      "method": "DELETE"
    },
    {
      "rel": "orders",
      "href": "/api/users/123/orders",
      "method": "GET"
    },
    {
      "rel": "posts",
      "href": "/api/users/123/posts",
      "method": "GET"
    }
  ]
}
```

**订单状态示例**（更实际的HATEOAS）：

json

```json
// 订单状态：待支付
{
  "orderId": 456,
  "status": "pending",
  "total": 99.99,
  "links": [
    {
      "rel": "payment",
      "href": "/api/orders/456/payment",
      "method": "POST"
    },
    {
      "rel": "cancel",
      "href": "/api/orders/456",
      "method": "DELETE"
    }
  ]
}

// 订单状态：已支付
{
  "orderId": 456,
  "status": "paid",
  "total": 99.99,
  "links": [
    {
      "rel": "shipment",
      "href": "/api/orders/456/shipment",
      "method": "GET"
    },
    {
      "rel": "invoice",
      "href": "/api/orders/456/invoice",
      "method": "GET"
    }
    // 注意：没有 payment 和 cancel 链接了
  ]
}
```

**HATEOAS的优势**：

1. **客户端不需要硬编码URL**

javascript

````javascript
// ❌ Level 2 做法（硬编码）
const deleteUrl = `/api/users/${userId}`;
fetch(deleteUrl, { method: 'DELETE' });

// ✅ Level 3 做法（动态）
const deleteLink = user.links.find(link => link.rel === 'delete');
fetch(deleteLink.href, { method: deleteLink.method });
```

2. **服务端控制客户端行为**
```
订单已发货 → 响应中没有"取消"链接 → 客户端UI自动隐藏"取消订单"按钮
```

3. **API演进更容易**
```
URL从 /api/v1/users/123 改为 /api/v2/users/123
客户端：不需要修改代码，因为是从链接中获取的
```

4. **自文档化**
```
客户端可以"发现"可用的操作
不需要单独的API文档说明"这个资源支持哪些操作"
````

### Level 2：客户端需要"预先知道"所有规则

**客户端必须硬编码**：

- 📖 哪些URL存在
- 📖 URL的格式
- 📖 什么状态下可以做什么操作
- 📖 业务逻辑规则

### Level 3：服务器"告诉"客户端可以做什么

**服务器通过链接引导**：

- 🔗 动态提供可用的操作
- 🔗 URL由服务器控制
- 🔗 业务规则由服务器执行
- 🔗 客户端"发现"而非"预知"



# Starbucks咖啡订单系统：案例研究


==无状态 = 每次请求都包含完整的信息==


## RESTful API关键原则

==**每个状态转换 = 一次HTTP操作**==

- 使用HTTP动词（GET, POST, PUT, DELETE, OPTIONS）
- 通过URI访问资源
- 每次交互都改变资源状态
==**OPTIONS 就是用来查询"我现在可以对这个资源做什么操作"**。==
==这体现了 RESTful 的**自描述性**原则：==

- ==❌ 不需要客户端提前知道所有业务规则==
- ==✅ 客户端动态发现当前能做什么==
- ==✅ 服务器控制业务逻辑，客户端只需跟随指引==

如果资源状态在请求前就已经发生改变（比如咖啡师已经开始做了）
	再次使用 OPTIONS
	更新成功后，FOLLOW THE LINK



**PUT是幂等的**：多次执行结果相同，不会重复添加






## 工具介绍

### 使用的工具

- **Python** - 编程语言
- **Pandas** - 数据处理
- **Flask RESTX** - REST API框架
- **Swagger** - API文档

---

## Flask 和 Flask RESTX

**Flask**

- Python微型Web框架
- 轻量级，但有良好的扩展能力

**Flask RESTX**

- Flask的扩展，用于快速构建REST API
- 鼓励最佳实践和最小化配置
- 提供装饰器和工具来描述API和暴露文档
- 使用Swagger生成文档
- 是Flask RESTPlus的分支项目，100%兼容

---

## Swagger

**功能**：

- 使用Flask RESTPlus时，自动生成Swagger API文档
- 文档在API根路径可访问，但需要提供`Api.doc()`装饰器的详细信息

**定义**：

- Swagger（现称"Open API Initiative"）是描述API的通用语言框架
- 像房屋蓝图，可以用任何材料建造，但不能超出蓝图参数










# 第二节：REST API design and REST Client


API的目标用户是**应用开发者**（其他程序员）
## 第二页：设计RESTful API的原则

**核心理念**：

**1. 易于理解**

- 让客户端无需深入研究API文档就能理解你的服务

**2. 自描述、自文档化**

- 尽可能做到自我说明

**3. 开发者友好**

- 客户端是像你一样的开发者
- 他们希望API易于上手

**4. RESTful原则是指南**

- REST服务原则为设计Web API提供了直接的指导

**5. 关键词：Clean, Clear, Consistent**

- **简洁、清晰、一致**







**URI设计要点**：

1. **使用名词，不用动词**
    - ❌ `/getItems`, `/createOrder`
    - ✅ `/items`, `/orders`
2. **使用复数形式**
    - ✅ `/orders` 而非 `/order`
3. **清晰的层级结构**
    - `/resources/{id}/sub-resources`
4. **查询参数用于过滤**
    - `/orders?status=pending&date=2024-11-30`
5. **关系表达清晰**
    - 嵌套：`/customers/123/orders`
    - 查询：`/orders?customer=123`





## 第一页：URI设计 - 添加动作/动词

**在资源URI上添加'动作/动词'来完成API端点**

### HTTP方法对应表

|资源 (URI)|GET|POST|PUT|DELETE|
|---|---|---|---|---|
|**/coffeeOrders**|获取订单列表  <br>返回列表，状态码200|创建新订单  <br>返回新订单+新URI，状态码201|批量更新  <br>状态码200, 204|ERROR (?)|
|**/coffeeOrders/123**|获取订单123  <br>返回一个项目，状态码200|ERROR (?)|更新订单123  <br>更新的项目，状态码200, 204|删除订单123  <br>状态码204, 200|

**注意点**：

- POST在集合资源上创建新项
- PUT在单个资源上更新现有项


---

## 第二页：如何使用状态码

### 基本原则

**正确且一致地使用状态码，帮助客户端更好理解交互**

### HTTP规范的最小状态码集

|代码|描述|何时使用|
|---|---|---|
|**200**|OK|一切正常|
|**400**|Bad Request|你（客户端）做错了什么|
|**500**|Internal Error|我们（服务器）做错了什么|

### 推荐使用更多状态码（但要限制数量，保持简洁）

|代码|描述|何时使用|
|---|---|---|
|**201**|Created|你的请求创建了新资源|
|**304**|Not Modified|已缓存|
|**404, 401, 403**|Not Found, Unauthorised, Forbidden|用于认证和授权|





## 第一页：决定响应格式

### 基本原则

**是否支持多种格式并允许客户端内容协商？（还是只用JSON？）**

**使用简单对象**：

- 单个结果 → 返回单个对象
- 多个结果 → 返回集合（包装在容器中）




## 第一页：提升API到下一个级别

### HATEOAS = Hypermedia As The Engine Of Application State
## 核心思想

**客户端不需要硬编码 URL，而是通过服务器返回的链接（超媒体）来导航**

### 不使用HATEOAS 
``` 
客户端：需要知道URL构造规则 
文档：必须详细说明所有端点 
变更：URL变化需要更新所有客户端 
``` 
### 使用HATEOAS 
``` 
客户端：跟随服务器提供的链接 
文档：响应本身就是文档 
变更：只需更新服务器返回的链接

```


## 第一页：API版本控制

### 为什么需要版本控制？

**问题**：

> 当你的API被全世界使用时，升级API并引入破坏性变更也会破坏使用你API的现有产品或服务。

### 最佳实践

**建议**：

> 尽量在路径中包含API版本，以最小化每个版本包含哪些功能的混淆。

**示例**：

```
http://api.yourservice.com/v1/stuff/34/things
```


---

## 第二页：标准化API规范

### OpenAPI规范（Swagger, swagger.io）

**定义**：

- RESTful API的标准、语言无关的接口定义

**功能**：

- ✅ 人类和计算机都能发现和理解服务能力
- ✅ 无需访问源代码、文档或网络流量检查
- ✅ "自动文档"（从规范生成）
- ✅ "自动检查/测试接口"
- ✅ "自动客户端代码生成"



以上是讲的如何创建一个api，以下讲解如何消费api



### 核心观点

**"客户端是预先编写的软件程序"** - 这意味着需要专门开发 REST 客户端代码来与 API 交互。


## 第一页：使用客户端-API交互模式

### 单页应用（SPA）的基本结构

**REST客户端应用可以设计成一个简单、重复的循环**：

**基本循环**：

1. 执行HTTP请求
2. 将响应（JSON）存储在内存中
3. 检查响应以获取当前上下文
4. 遍历响应并在屏幕上渲染与上下文相关的信息




### Python中的Requests库

**Requests能做什么？**

> Requests允许你使用Python发送HTTP/1.1请求。通过它，你可以添加内容，如头部、表单数据、多部分文件和参数，通过简单的Python库。它还允许你以同样的方式访问Python的响应数据。

记得检查状态码

## 第一页：缓存API请求

### 实现缓存

**工具**：Requests-cache

> 要实现缓存，我们可以使用一个简单的包叫做 Requests-cache，它是一个"透明的持久化请求缓存"。
### 工作原理（简单方法）

python

```python
import requests_cache

requests_cache.install_cache(
    cache_name='mystuff_cache',
    backend='sqlite', 
    expire_after=180
)
```

**说明**：

- 默认情况下，缓存保存在sqlite数据库中
- 也可以使用Python dict、redis和mongodb

## 应对变化
### Must Ignore 原则

**定义**：

> HTTP指令"MUST IGNORE" = 接收方不理解的响应中的任何元素必须被忽略，而不停止对响应的进一步处理。

旧版本客户端收到新版本响应，包含新版本才有的字段，旧版本客户端不认识它，那么就应该直接忽略继续处理
### 向后兼容的好处

**1. 平滑升级**

- API可以添加新功能
- 旧客户端继续工作
- 不需要强制所有客户端同时升级

**2. 渐进式演进**

- 新功能逐步推出
- 用户可以选择何时升级
- 减少中断风险



# 第三节：Week 6: RESTful API Security

## 第一页：安全的关键方面

### 安全定义

> "IT系统提供的安全可以定义为IT系统能够保护处理数据的**机密性**和**完整性**，提供系统和数据的**可用性**，为处理的事务提供**问责性**，以及**保证**系统将继续按照其设计目标运行。"

### 五个关键要素

**1. Confidentiality（机密性）**

- 保护数据不被未授权访问
- 只有授权用户能看到敏感信息

**2. Integrity（完整性）**

- 确保数据未被篡改
- 数据准确和完整

**3. Availability（可用性）**

- 系统和数据在需要时可访问
- 防止拒绝服务

**4. Accountability（问责性）**

- 追踪谁做了什么
- 审计和日志记录

**5. Assurance（保证）**

- 系统按设计目标持续运行
- 符合安全要求和标准




## ==九大安全设计原则详解==

**1. Least Privilege（最小权限）**

> 系统的每个程序和每个用户都应该使用完成工作所需的最小权限集进行操作。

**实际应用**：

- API用户只能访问其需要的端点
- 读取权限 vs 写入权限分离
- 管理员 vs 普通用户权限区分

---

**2. Fail-Safe Defaults（安全失败默认值）**

> 基于允许而非排除的访问决策。这个原则意味着默认情况是缺乏访问权限，保护方案确定允许访问的条件。

**实际应用**：

python

```python
# ✅ 安全失败默认
def check_access(user, resource):
    if user.has_permission(resource):
        return True
    return False  # 默认拒绝

# ❌ 不安全的默认
def check_access(user, resource):
    if user.is_blocked(resource):
        return False
    return True  # 默认允许
```

---

**3. Economy of Mechanism（机制经济性）**

> 保持设计尽可能简单和小型。这个众所周知的原则适用于系统的任何方面。

**实际应用**：

- 简单的认证流程比复杂的更安全
- 代码越少，漏洞越少
- 易于审计和验证

---

**4. Complete Mediation（完全中介）**

> 必须检查对每个对象的每次访问是否有权限。这个原则意味着必须设计一种万无一失的方法来识别每个请求的来源。

**实际应用**：

python

```python
# ✅ 每次都检查
@app.route('/api/data/<id>')
def get_data(id):
    user = authenticate(request)  # 每次都验证
    if not user.can_access(id):
        return 403
    return get_resource(id)

# ❌ 依赖缓存的权限
cached_permission = check_once()
# 后续不再检查
```

---

** 5. Open Design（开放设计）**

> 设计不应该保密。机制不应该依赖于潜在攻击者的无知，而应该依赖于特定的、更容易保护的密钥或密码。

**实际应用**：
- 使用标准加密算法（AES、RSA）
- 安全性在于密钥，而非算法
- 公开的OAuth 2.0协议

**对比**：
```
❌ 自创加密算法（通过隐藏设计保护）
✅ 使用AES加密（通过密钥保护）
```

---

**6. Separation of Privilege（权限分离）**

> 如果可行，需要两个密钥来解锁的保护机制比只允许单个密钥持有者访问的机制更健壮和灵活。

**实际应用**：

- 双因素认证（密码 + 手机验证码）
- 多重签名（两个管理员都要批准）
- 关键操作需要多个条件


---

**7. Least Common Mechanism（最少共享机制）**

> 最小化多个用户共同使用并依赖的机制数量。

**实际应用**：

- 避免全局状态
- 用户数据隔离
- 独立的数据库连接池

**示例**：

python

```python
# ❌ 共享机制
global_cache = {}  # 所有用户共享

# ✅ 隔离机制
user_caches = {}  # 每个用户独立缓存
```

---

**8. Psychological Acceptability（心理可接受性）**
> 人机界面必须设计为易于使用，这样用户才会例行和自动地正确应用保护机制。

**实际应用**：
- 简单的登录流程
- 清晰的错误信息
- 用户友好的2FA

**对比**：
```
❌ 复杂：需要记住20位随机密码，每天更换
✅ 可接受：密码管理器 + 生物识别
```

---

**9. Defense in Depth（深度防御）**
> 一种分层防御机制的方法，以保护有价值的数据和信息。如果一个机制失败，另一个立即介入以阻止攻击。

**实际应用**：
```
多层防护：
1. 网络层：防火墙
2. 传输层：HTTPS
3. 应用层：认证/授权
4. 数据层：加密存储
5. 监控层：入侵检测

如果一层被突破，其他层仍能保护
```




