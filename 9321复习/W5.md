Web server part 2


==很重要==
## Architectural Constraints of REST
1.client-server
2.uniform interface
3.statelessness
4.caching
5.layered system

# 统一接口 - 链接资源（Linked Resources）- 笔记

## 一、表现形式是超媒体

### 核心概念

**表现形式是超媒体：资源（数据本身）+ 链接到其他资源**


## 二、REST 中的连接性

### 三种服务级别

```
连接性程度：
低 ← ─────────────────────── → 高

a          b          c
```

**示意图说明**：

- **a**：少量独立的盒子
- **b**：一些盒子有连接
- **c**：盒子之间密集连接，形成网络

---

### 三种服务对比

**所有三种服务都暴露相同的功能，但可用性向右递增**

#### Service A（服务 A）

**特点**：

- 典型的远程函数调用风格服务
- 通过单一 URI 暴露所有内容
- **既不可寻址，也不连接**

**问题**：

```
所有功能 → 单一入口点
         → 无法直接访问特定资源
         → 无法发现相关资源
```

**类比**：

- 像一个黑盒 API
- 必须知道确切的函数调用
- 没有探索性

---

#### Service B（服务 B）

**特点**：

- **可寻址但不连接**
- 资源之间没有关系指示
- 混合风格

**优势**：

- ✅ 每个资源有独立的 URI
- ✅ 可以直接访问特定资源

**劣势**：

- ❌ 资源之间没有链接
- ❌ 无法发现相关资源
- ❌ 需要外部文档说明关系

**例子**：

```
/users/123       ← 可以直接访问
/orders/456      ← 可以直接访问
但不知道这个用户有哪些订单
```

---

#### Service C（服务 C）

**特点**：

- **可寻址且连接良好**
- 资源之间以有意义的方式链接
- **完全 RESTful 的服务**

**优势**：

- ✅ 每个资源有独立的 URI
- ✅ 资源包含到相关资源的链接
- ✅ 可发现性强
- ✅ 自文档化

**例子**：

```
GET /users/123
{
  "id": 123,
  "name": "Alice",
  "links": {
    "orders": "/users/123/orders",
    "profile": "/users/123/profile",
    "friends": "/users/123/friends"
  }
}
```



# 无状态性（Statelessness）- REST 约束 3 - 笔记

## 一、无状态性定义

**REST API 必须是无状态的**

- 所有来自客户端的调用都是独立的
- 每个 HTTP 请求都在完全隔离的环境中发生

---

## 二、无状态的好处

✅ 可扩展（Scalable）  
✅ 易于缓存（Easy to cache）  
✅ 可寻址的 URI 可以被收藏（例如：搜索结果的第 10 页）

---

## 三、HTTP 会话问题

**HTTP 本质上是无状态的，但我们需要打破它来构建应用**

### 最常见方式：HTTP 会话

**工作原理**：

1. 用户首次访问网站，获得唯一会话 ID
2. 示例：`http://www.example.com/forum?PHPSESSIONID=27314962133`
3. 会话 ID 是服务器上数据结构的键
4. 包含用户操作记录
5. 所有交互都依赖这个键

---

## 四、什么才算"状态"？

### 场景：类似 Flickr 的网站

添加照片、重命名照片、分享照片等

"无状态"在这里意味着什么？

---

## 五、关键概念

### **分离客户端应用状态和 RESTful 资源状态**

#### 应用状态（Application State）

- 可能因客户端和请求而异的数据
- 每个客户端不同

#### 资源状态（Resource State）

- 可以由服务器集中管理的数据
- 对每个客户端都相同

---

## 六、REST 的要求

✅ **资源状态存储在服务器上** ❌ **客户端应用状态应该远离服务器**





这个PPT讲解的是REST架构中的**无状态性（Statelessness）**原则。让我详细解释一下：

## 核心概念

==**无状态性在REST中的含义**：从服务器的角度来看，客户端应用的状态信息不应该保存在服务器端。==

## 对客户端应用的意义

PPT列出了两个关键点：

1. **每个REST请求都应该是完全自描述的**（be totally self-descriptive）
    - 这意味着每个请求必须包含服务器处理该请求所需的所有信息
    - 服务器不应该依赖之前请求中的任何信息
2. **客户端需要在每次请求时传输状态信息给服务器**
    - 状态信息通过以下三个部分传输：
        - HTTP请求（URL和参数）
        - HTTP请求头（例如accept类型）
        - 请求体内容（Body Content）

## RESTful服务的要求

PPT强调：RESTful服务要求应用状态保持在客户端。服务器不代表客户端保存应用状态。

## 与OAuth的关系

最后提出了一个思考问题：**OAuth与REST的无状态性是否冲突？**

这是一个有趣的问题，因为OAuth在认证流程中确实需要维护一些状态（比如授权码、token等），但这通常通过token机制来实现，token本身携带了认证信息，所以在某种程度上仍然符合无状态原则。

## 总结

这个PPT的核心思想是：在REST架构中，服务器不应该记住客户端的状态，每次请求都应该是独立且完整的，所有必要信息都由客户端提供。





## 第一页：缓存的基本概念

### 核心要求

响应必须被标记为"可缓存"或"不可缓存"

### 缓存的好处

**良好管理的缓存可以部分或完全消除某些客户端-服务器交互，从而提高可扩展性和性能。**

### 无状态性与缓存的关系

**无状态性的影响**：

- ✅ **优点**：保持交互协议更简单
- ⚠️ **缺点**：交互可能变得"更啰嗦"（chattier）
    - 因为每次请求都要携带完整信息，数据传输量增加

### RESTful API的扩展要求

为了扩展，RESTful API必须**工作害羞**（work-shy）：

- 只在需要时生成数据流量
- 其他时间使用缓存

### 服务器-客户端协作机制

**这需要服务器和客户端的协作**，通过以下方式实现：

1. **客户端提供守护子句**（guard clauses）
    - 让服务器能够轻松判断是否有工作需要完成
2. **使用HTTP缓存头**：
    - `If-Modified-Since`：如果自某时间后修改过
    - `Last-Modified`：最后修改时间
    - `If-None-Match`：配合ETag使用
    - `ETag`：实体标签

---

## 第二页：定义最优缓存控制策略

这是一个**决策流程图**，帮助确定如何设置Cache-Control策略：

### 决策流程

1. **响应可重用吗？**（Reusable response?）
    - ❌ **No** → 设置 `no-store`
    - ✅ **Yes** → 继续下一步
2. **每次都需要重新验证吗？**（Revalidate each time?）
    - ✅ **Yes** → 设置 `no-cache`
    - ❌ **No** → 继续下一步
3. **可被中间缓存缓存吗？**（Cacheable by intermediate caches?）
    - ❌ **No** → 设置 `private`（仅浏览器缓存）
    - ✅ **Yes** → 设置 `public`（可被代理、CDN等缓存）
4. **最大缓存生命周期？**（Maximum cache lifetime?）
    - 设置 `max-age=...`（秒数）
5. **添加ETag头**
    - 用于缓存验证