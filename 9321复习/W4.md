# 数据服务


**模块化与接口化**：每个团队作为“服务”提供方，必须通过接口暴露其功能与数据；内部不能随意绕过接口。

“Web三个基本组成要素：

⭐ URL：统一资源定位符，负责“资源地址”。  
⭐ HTTP：用于在客户端／服务器之间传递请求与响应消息。  
⭐ HTML：用于格式化网页结构与内容。


![](assets/W4/file-20251126125806783.png)

**HTTP 请求（从浏览器至服务器）：**  
它由 **请求行（Request Line） + 报头（Header） + （可选）附加数据（additional data）** 构成。
请求行示例：
GET http://www.smh.com.au/index.html HTTP/1.1
在报头与附加数据部分之间必须有一个新行（CRLF）。

常见的请求方法（Request methods）：GET、POST、HEAD…

请求报头（Request header）可能包括：User-Agent、Referer、Authorization 等。

附加数据（body）：一般用于 POST 参数、数据块。


![](assets/W4/file-20251126130412869.png)


**HTTP Response（从服务器到浏览器）：**

- 由 **状态行（Status Line） + 报头（Header） + 主体（Body）** 构成。
    
- 状态行示例：`200 OK`、`404 Not Found` 等。
    
- 报头（Header）包括：`Content-Type`、`Content-Language`、`Content-Length`、`Cache-Control` 等。
    
- 主体（Body）：
    
    - 包含请求的资源数据。
        
    - 主体按特定 MIME 格式（例如 `text/HTML`）呈现。
        
    - MIME（Multipurpose Internet Mail Extension）：可以是纯文本、HTML、多媒体数据、应用程序格式例如 PDF、PowerPoint 等。



![](assets/W4/file-20251126130557882.png)


⭐ **早期网页架构**：2000 年代初很多站点结构简单、主要面向人类用户浏览器与 HTML 页面交互，整合方式多为“模拟浏览器点击／请求其它网站数据”。


服务化／API 化——站点开始暴露更明确的数据接口（如 XML、JSON 或专门的 API 域名），而不是仅通过网页 UI 获取信息。


一个 WebService 是一种“Consumer_Machine（消费者机器）→ Provider_Machine（提供者机器）”通过计算机网络协作的 schema（模式 / 架构）。


**Why Web Services（为什么要使用 Web Services）**

- 有很多情形下，需要处理的数据非常庞大，或频繁变化，不应该 (cannot / should not) 被硬编码 (hardcoded) 到应用 中。相反，这类数据应当从可靠的外部来源请求 (request) —— 例如，现在欧元兑美元的汇率是多少？
    
- 还有一类应用可能需要非常高的计算能力，这在移动设备上可能不可用。想象的问题例如：在两个地图坐标之间寻找最短 / 最快路线、为旅客选择最佳机票和路线。




**非人工交互界面**

- API不是为人类用户设计的界面，而是程序之间的通信接口
- 需要明确的合约规范（如IOU Alice Bob 100这样的例子）

**内部与外部使用**

- 现代公司既在内部使用API（私有API）
- 也对外提供API服务（公共API）



| 方面       | SOAP                    | REST                 |
| -------- | ----------------------- | -------------------- |
| **复杂度**  | 复杂，需要XML信封              | 简单，使用URL             |
| **格式**   | 严格的XML                  | 灵活（文本/HTML/XML/JSON） |
| **传输协议** | 多种（HTTP/HTTPS/FTP/SMTP） | 主要是HTTP/HTTPS        |
| **服务发现** | 有WSDL工具                 | 缺乏标准探索工具             |
| **开销**   | 较大（创建和解析XML）            | 较小                   |
| **灵活性**  | 低（格式固定）                 | 高（格式自由）              |
- **REST是架构风格**，不是协议
- **以资源为中心**的设计思想
- **使用标准HTTP方法**（GET、POST、PUT、DELETE等）
- **无状态通信**，每个请求独立
- **JSON格式**已成为REST API的事实标准
- **URI作为资源定位**的唯一标识



## 资源是 REST 的核心

**关键概念**：在 REST 中，一切始于资源，资源是基本单位。

## 什么是资源？

**定义**：任何可以被命名的信息都可以是资源，包括：

- 文档或图像
- 临时服务（如洛杉矶今日天气）
- 其他资源的集合
- 非虚拟对象（如人）
- 任何可能成为作者超文本引用目标的概念

## 资源的具体特征

一个资源必须满足：

- **唯一性** - 可被唯一标识
- **至少一种表现形式** - 可以用某种方式呈现
- **有属性** - 除了ID之外还有其他属性
- **有定义/模式** - 具有潜在的结构定义
- **有状态** - 可提供上下文（状态可以改变/更新）
- **可寻址** - 在可寻址的范围内可访问
- **有关系** - 可以是集合或关系






## 表现层状态转移（Representational State Transfer）

**核心概念**：REST 是一个 Web 资源网络（虚拟状态机），用户通过以下方式在应用中进行导航：

- **选择链接**：如 /students/M. Scott
- **执行操作**：如 GET 或 DELETE（状态转换）
- **结果**：进入下一个资源，代表应用的下一个状态
- **状态转移**：新状态被传递给用户使用

**示例流程**： 查询 M. Scott → 显示学生列表 → 选择 M. Scott → 显示详细信息 → Done 或 Cancel

---

## 资源的多重表现形式

**关键原则**：REST 不指定"标准数据格式"，而是**基于消费者的需求**提供不同格式。

**同一资源（M.Scott state）可以有多种表现形式**：

通过"业务逻辑"读取后，根据不同需求输出：

- **HTML** - 用于浏览器
- **XML** - 用于其他应用
- **JSON** - 用于移动应用
- **Image** - 图像格式
- **PDF** - PDF 文档
- **TEXT** - 纯文本



RESTful 服务/API 必须通过遵循设计指南/原则来满足架构约束。

## REST 的六大架构约束

1. **Client-Server（客户端-服务器）**
    - 客户端和服务器分离
2. **Uniform Interface（统一接口）**
    - 标准化的交互方式
3. **Statelessness（无状态性）**
    - 每个请求独立，服务器不保存客户端状态
4. **Caching（缓存）**
    - 响应可以被缓存以提高性能
5. **Layered System（分层系统）**
    - 可以有中间层（如代理、网关）
6. **Code on demand（按需代码）** - 可选
    - 服务器可以发送可执行代码给客户端




## 统一接口 - 资源 URI

### 核心原则

**资源通过 URI 标识（Uniform Resource Identifier）** **一个资源至少要有一个 URI**

### 常见的 URI 类型

#### 1. URN（Uniform Resource Name - 统一资源名称）

**名称标识，与位置无关**

示例：

- `urn:isbn:0-486-27557-4`（莎士比亚的《罗密欧与朱丽叶》书籍）
- `urn:isan:0000-0000-9E59-0000-O-0000-0000-2`（2002年蜘蛛侠电影）

#### 2. URL（Uniform Resource Locator - 统一资源定位符）

**位置标识，指向资源所在位置**

示例：

- `file:///home/tommy/plays/RomeoAndJuliet.pdf`
- `http://home/tommy/plays/RomeoAndJuliet.html`

### 重要原则

**每个 URI 精确指定一个资源**


---

## 统一接口 - 可寻址性（Addressability）

### 核心要求

**资源必须是可寻址的**

### 什么是"可寻址"？

**定义**：应用程序将其数据集作为资源公开（通常是大量的 URI）

### 可寻址系统的例子

✅ **计算机文件系统**

- 每个文件都有唯一路径
- 可以通过路径访问

✅ **电子表格中的单元格**

- 通过单元格引用寻址（如 A1, B2）

✅ **Flickr（图片分享网站）**

- "可寻址"Web 的好例子
- 可以收藏、在程序中作为链接使用、通过邮件发送等

### 不可寻址的系统

❌ **某些数据库查询结果**

- 没有固定的 URI

❌ **临时生成的内容**

- 无法被持久引用






# 统一接口 - 表现形式（Representations）- 笔记

## 核心概念

### 资源需要表现形式才能发送给客户端

**表现形式 = 资源"当前状态"的某些数据**

---

## 一、什么是表现形式？

### 定义

资源的表现形式是关于资源当前状态的数据

### 示例：软件项目的开放 bug 列表

同一个资源可以有多种表现形式：

- **XML 文件**
- **网页**（HTML）
- **逗号分隔值**（CSV）
- **打印友好格式**等


---

## 二、表现形式的双向流动

### 不仅仅是服务器到客户端

**反向流动也可以**：

- 客户端发送资源的新的或更新的"表现形式"
- 服务器创建/更新资源

**例如**：

```
客户端 → 发送新书信息（JSON/XML）→ 服务器
服务器 → 创建新的书籍资源
```

---

## 三、提供多种表现形式

### 应该提供多个表现形式

**在多个表现形式之间做选择**

### 选项 1：为每个表现形式提供不同的 URI

**示例：同一文档的不同语言版本**

```
http://www.example.com/release_doc/104.en  (英语)
http://www.example.com/release_doc/104.es  (西班牙语)
http://www.example.com/release_doc/104.fr  (法语)
```

### 评价

✅ **优点**：看起来非常"可寻址" → 好！

**含义**：

- 每个版本都有独立的 URI
- 可以直接收藏、分享特定语言版本
- 符合 REST 的可寻址性原则




### 选项 2：内容协商（Content Negotiation）

**使用 HTTP HEAD（元数据）进行内容协商**

#### 实现方式

**暴露单一 URI**：

```
http://www.example.com/release_doc/104
```

**客户端 HTTP 请求包含 Accept-Language**：

```
GET /release_doc/104 HTTP/1.1
Host: www.example.com
Accept-Language: es  (西班牙语)
```

#### 内容协商（HTTP 规范的一部分）

**其他类型的请求元数据可以设置以指示各种客户端偏好**：

- 文件格式（file format）
- 支付信息（payment information）
- 认证凭证（authentication credentials）
- 客户端 IP 地址（IP address of the client）
- 缓存指令（caching directives）
- 等等

#### 结论

**选项 1 或选项 2 都是可接受的基于 REST 的解决方案**

---

## 二、统一接口 - 描述语法（Description Syntax）

### 核心原则

**使用纯 HTTP 方法作为资源的主要操作**

### HTTP 规范对以下方法的说明

#### 主要 HTTP 方法

**GET**：检索资源的表现形式

- 只读操作
- 不改变服务器状态

**PUT**：创建新资源（新 URI）或更新资源（现有 URI）

- 创建：如果 URI 不存在，创建新资源
- 更新：如果 URI 已存在，替换现有资源

**DELETE**：清除资源，之后 URI 不再有效

- 删除后该 URI 应返回 404

**POST***：修改资源的状态

- POST 是读写操作，可能改变资源状态并在服务器上引发副作用
- Web 浏览器在刷新 POST 生成的页面时会发出警告
- 关于其确切的最佳实践用法存在争议

**HEAD, OPTIONS 和 PATCH**

- 辅助方法

---

## 三、与 CRUD 的对应关系

### 类似于 CRUD（创建、读取、更新、删除）数据库操作

|HTTP 方法|CRUD 操作|说明|
|---|---|---|
|**POST**|Create|创建（有争议）|
|**GET**|Read|读取|
|**PUT**|Update|更新/创建|
|**DELETE**|Delete|删除|

**注意**：POST 的确切最佳实践用法存在争议





REST 要求使用统一接口！




# 统一接口 - POST、PUT 和 PATCH - 笔记

## 一、POST 和 PUT 的区别

### POST - 创建新资源

**特点**：

- 创建新资源
- **服务器决定资源的 URI**
- 在响应中返回新 URI


---

### PUT - "创建"或"更新"资源

**特点**：

- **URI 在请求中由客户端给出**
- 如果资源已存在，包含的实体被视为资源的修改版本
- 如果资源不存在，则创建新资源

---

### 一般规则

**通常：POST 用于创建，PUT 用于更新**

|方法|用途|URI 决定者|幂等性|
|---|---|---|---|
|**POST**|创建|服务器|❌|
|**PUT**|更新/创建|客户端|✅|

---

## 二、PUT 和 PATCH 的区别

### PATCH - 部分更新

**历史**：

- PATCH 是后来添加到 HTTP 规范中的
- 用于支持资源的"部分更新"

### HTTP 规范说明

**PUT 请求**：

- 包含的实体被视为**存储在原始服务器上的资源的修改版本**
- 客户端请求**替换**存储的版本

**PATCH 请求**：

- 包含的实体包含一组**指令**
- ==描述如何**修改**当前驻留在原始服务器上的资源==
- 以产生新版本

---

### 实际示例

**场景：更新学生的出生日期**

#### 使用 PUT（完整替换）

```
PUT /students/0001
Content-Type: application/json

{
  "id": "0001",
  "name": "Alice",
  "DOB": "12/12/1990",
  "major": "Computer Science",
  "GPA": 3.8
}
```

- 必须发送**完整的**资源表现形式
- 替换整个资源

#### 使用 PATCH（部分更新）

```
PATCH /students/0001
Content-Type: application/json-patch+json

[
  {
    "op": "replace",
    "path": "/DOB",
    "value": "12/12/1990"
  }
]
```

- 只发送**需要修改的部分**
- 包含修改指令

---

### PATCH 的特性

**既不安全也不幂等**

**为什么不幂等？**

```
第一次 PATCH: { "op": "add", "path": "/tags", "value": "urgent" }
→ tags: ["urgent"]

第二次相同的 PATCH: { "op": "add", "path": "/tags", "value": "urgent" }
→ tags: ["urgent", "urgent"]  // 可能重复添加
```

---

# 统一接口 - 安全性与幂等性 - 笔记

## 一、核心概念

### 统一接口必须是安全的和幂等的

---

## 二、安全性（Being Safe）

### 定义

**只读操作**

- 对资源的操作**不改变任何服务器状态**
- 客户端可以调用操作 10 次，对服务器状态没有影响

---

## 三、幂等性（Being Idempotent）

### 定义

**无论应用一次还是多次，都有相同的"效果"**

- 这里的效果可能是服务器状态的改变
- 对资源的操作是幂等的：**一次请求 = 多次相同请求**

---

## 四、各 HTTP 方法的安全性和幂等性

### GET - 安全且幂等 ✅✅

```
GET /users/123
→ 返回用户信息
→ 不改变服务器状态（安全）
→ 多次调用返回相同结果（幂等）
```

### HEAD 和 OPTIONS - 安全 ✅

```
HEAD /users/123
→ 返回响应头，不返回主体
→ 不改变服务器状态

OPTIONS /users
→ 返回允许的方法
→ 不改变服务器状态
```

---

### PUT - 幂等 ✅

**创建资源**：

```
第一次 PUT /users/123
{
  "name": "Alice",
  "email": "alice@example.com"
}
→ 创建用户 123

再次 PUT /users/123
{
  "name": "Alice",
  "email": "alice@example.com"
}
→ 资源仍然存在，属性相同（幂等）
```

**更新资源**：

```
第一次 PUT /users/123
{
  "name": "Bob",
  "email": "bob@example.com"
}
→ 更新用户信息

再次 PUT /users/123
{
  "name": "Bob",
  "email": "bob@example.com"
}
→ 资源状态不会再次改变（幂等）
```

---

### DELETE - 幂等 ✅

```
第一次 DELETE /users/123
→ 删除用户 123
→ 返回 200 OK 或 204 No Content

第二次 DELETE /users/123
→ 用户仍然是删除状态（gone）
→ 可能返回 404 Not Found，但资源仍然"不存在"（幂等）
```

**关键点**：多次删除同一资源，最终结果相同（资源不存在）

---

### POST - 既不安全也不幂等 ❌❌

**那么 POST 呢？**

```
第一次 POST /orders
{
  "item": "laptop",
  "quantity": 1
}
→ 创建订单 #001

第二次 POST /orders
{
  "item": "laptop",
  "quantity": 1
}
→ 创建订单 #002（不同的订单！）
```

**问题**：

- ❌ 不安全：改变服务器状态（创建新资源）
- ❌ 不幂等：每次创建新的不同资源




## 一、为什么安全性和幂等性很重要？

### 核心原因

**这两个属性让客户端能够在不可靠的网络上发出可靠的 HTTP 请求**

---

## 二、实际应用场景

### 场景 1：GET 请求失败

**关键点**：你的 GET 请求没有响应？再发一个！安全！

---
## 三、常见的错误用法

### 许多应用误用 HTTP 统一接口

**错误示例 1**：用 GET 执行删除操作 ❌

```
GET https://api.del.icio.us/posts/delete
```

- GET 应该是安全的（只读）
- 删除操作改变了服务器状态
- 这违反了 GET 的语义

---

### 问题所在

**许多应用将不安全的操作暴露为 GET**

- 有很多 POST 操作的使用既不安全也不幂等
- **重复执行这些操作会产生后果**

**实际风险**：

```
场景：用户点击"提交订单"按钮

如果使用 POST（非幂等）：
用户点击 → POST /orders → 创建订单 #001
网络慢，用户再点击 → POST /orders → 创建订单 #002
结果：重复下单！💸💸

如果设计得当（使用幂等操作）：
可以安全地重试而不会重复
```

---

## 四、为什么安全性和幂等性对统一性很重要

### 允许 REST 接口的"统一性"

**这是社区接受的约定**

### REST 统一接口的要点

**统一性在于：每个服务以相同方式使用 HTTP 接口**

#### 含义 1：语义一致性

```
GET 在整个 Web 上都意味着"只读"
→ 无论你使用哪个资源

例如：
GET /books/123     → 只读
GET /users/456     → 只读
GET /orders/789    → 只读
```

#### 含义 2：不要自定义方法名

```
❌ 错误：不要用自定义方法替代标准 HTTP 方法

不要使用：
- doSearch
- getPage
- nextNumber

✅ 正确：使用标准 HTTP 方法
- GET
- POST
- PUT
- DELETE
```

---

### 关键理解

**不仅仅是在服务中有一个叫 GET 的方法**

**而是要按照其设计意图来使用它**

```
不是：有 GET 方法就行
而是：正确使用 GET 方法

GET 的意图 = 安全的、只读的操作
```

---

## 五、正确 vs 错误的设计

### ❌ 错误设计

```
// 用 GET 删除
GET /api/users/delete?id=123

// 用 GET 创建
GET /api/users/create?name=John&email=john@example.com

// 用 POST 做所有事情
POST /api/doEverything
{
  "action": "getUser",
  "userId": 123
}
```

**问题**：

- 违反了 HTTP 方法的语义
- 破坏了统一接口的约定
- 使客户端无法安全地重试
- 缓存机制失效

---




# 第二节：数据可视化

## 二、饼图（Pie Charts）

### 特点与使用建议

**虽然常用，但不被认为是有效形式**：

- 人脑不善于解析圆形区域和弧度
- 难以精确比较大小

**替代方案**：

- 通常其他图表可以完成相同工作（如柱状图）

**可接受的使用场景**：

- 显示两个变量（<、>、相似等）
- 变量数量很少时



---

## 三、直方图（Histograms）

### 用途

**用于查看（或真正发现）数据点的分布**

### 分箱（Bins）的重要性

**分箱（离散化）帮助我们看到"更大的图景"**：

- 如果使用所有数据点而不使用离散的分箱
- 可视化中会有大量噪音
- 难以看清真正的趋势


---

## 四、层次数据可视化

### 目的

**展示对象之间的"连接"和层次结构**


---

## 五、在地图上显示数据

### 使用现有地图 API（如 Google API）

#### 1. 地点标记（Place Markers）

**链接**：[https://www.latlong.net/](https://www.latlong.net/)

**用途**：

- 标记特定位置（如建筑物）
- 标记区域中心

#### 2. 图层（Layers）

**用途**：

- 与地图上的区域关联的数据

#### 3. 点聚类（Point Clustering）

**链接**：[http://bl.ocks.org/andrewxhill/raw/8360694/](http://bl.ocks.org/andrewxhill/raw/8360694/)

**用途**：

- 按区域显示聚合的数字/数据点

#### 4. 等值区域图（Choropleth Map）

**链接**：[http://leafletjs.com/examples/choropleth/](http://leafletjs.com/examples/choropleth/)

**用途**：

- 显示根据数据变量进行着色、阴影或图案化的地理区域
- 通过颜色深浅表示数据强度

#### 5. 热力图（Heat Map）

**链接**：[https://onemilliontweetmap.com/](https://onemilliontweetmap.com/)

**用途**：

- 显示数据密度和强度

#### 6. 流向图（Flow Map）

**用途**：

- 显示信息或对象从一个位置到另一个位置的移动
- 通过线条粗细和颜色表示流量大小

**相关链接**：

- [https://datavzcatalogue.com/methods/flow_map.html](https://datavzcatalogue.com/methods/flow_map.html)
- [https://www.iom.int/world-migration](https://www.iom.int/world-migration)





### 多种方式用更少做更多
1. 多个简单图
2. 融合图
3. 多个轴：画多个不同的事物在一个图上



## 两个权衡（Two Tradeoffs）

### 1. 信息量 vs. 可读性（Informativeness vs. Readability）

**问题**：

- 信息太少 → 可能隐藏数据
- 信息太多 → 可能让人不知所措

**可能的解决方案**：

- 分层组织（Hierarchical organization）

---

### 2. 以数据为中心 vs. 以观众为中心（Data-centric vs. Viewer-centric）

**观众导向**：

- 观众习惯于特定类型的可视化
- 使用熟悉的图表类型

**数据导向**：

- 新颖的可视化可以更真实地反映数据
- 可能需要打破常规

---

## 综合建议

### 基本能力要求

**有很多可视化数据的选项**（包括最新工具和库的花哨交互式选项）

**但首先要在以下方面具备基本能力**：

1. **准确性很重要，有清晰的故事要讲很重要**
2. **需要准备好进行一些基本的数据准备和预分析后再可视化**
3. **了解故事的正确范式（形式）**
4. **意识到自己作为"非专家"的局限性**（可视化并不容易）

### 实用技巧

**实际上，很多专家推荐"用纸笔勾勒想法"**

_（图片显示手绘草图示例）_

**原因**：

- 快速迭代想法
- 专注于概念而非工具
- 降低修改成本
- 激发创造性思维







## Python 数据可视化库概览

### 1. Matplotlib

**特点**：

- 低级库
- 提供大量自由度
- 灵活但需要更多代码

**适合场景**：

- 需要精细控制图表的每个细节
- 自定义复杂可视化

---

### 2. Pandas Visualization

**特点**：

- 易于使用的接口
- 构建在 Matplotlib 之上
- 与 DataFrame 无缝集成

**适合场景**：

- 快速探索性数据分析
- 简单直接的可视化需求

**示例**：

python

```python
df.plot()  # 简单一行代码
```



### 何时 .plot() 最有用？

**当你有一个有意义的索引时**、
### 情况 1：使用 .value_counts() 或 .groupby()

**操作后的结果**：

- 这些操作会创建有意义的索引
- 索引成为分组的标签
### 情况 2：使用 .set_index()

**特别是设置日期索引**